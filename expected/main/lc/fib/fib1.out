data -> (a :: *) (b :: *)
  = Func ([a] ->> [b])

bitdata Bool /1
  = False [ B0 ]
    -- predFalse(x :: Bit 1) = x == 0b0
  | True [ B1 ]
    -- predTrue(x :: Bit 1) = x == 0b1

-- bit pattern:
--  _

data Proc (a :: *)
  = Proc ([] ->> [a])

data Unit
  = Unit

-----------------------------------------
-- not recursive
entrypoint false :: Bool
false <-
  False()

-----------------------------------------
-- not recursive
entrypoint bfalse :: [] >>= [Bool]
bfalse[] =
  return false

-----------------------------------------
-- not recursive
entrypoint true :: Bool
true <-
  True()

-----------------------------------------
-- not recursive
entrypoint btrue :: [] >>= [Bool]
btrue[] =
  return true

-----------------------------------------
-- not recursive
entrypoint bconv :: [Bit 1] >>= [Bool]
bconv[t0] =
  if t0
    then btrue[]
    else bfalse[]

-----------------------------------------
-- not recursive
b42 :: [Word, Word] >>= [Bool]
b42[t0, t1] =
  t2 <- primEq((t0, t1))
  bconv[t2]

-----------------------------------------
-- not recursive
k27 :: {Word} [Word] ->> [Bool]
k27{t0} t1 = b42[t0, t1]

-----------------------------------------
-- not recursive
b43 :: [Word] >>= [Word -> Bool]
b43[t0] =
  t1 <- k27{t0}
  Func(t1)

-----------------------------------------
-- not recursive
k28 :: {} [Word] ->> [Word -> Bool]
k28{} t0 = b43[t0]

-----------------------------------------
-- not recursive
b44 :: [] >>= [Word -> Word -> Bool]
b44[] =
  t0 <- k28{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint eq :: Word -> Word -> Bool
eq <-
  b44[]

-----------------------------------------
-- not recursive
b90 :: [Word] >>= [Word]
b90[t0] =
  return t0

-----------------------------------------
-- not recursive
b95 :: [] >>= [Word]
b95[] =
  t0 <- return 0
  b90[t0]

-----------------------------------------
-- not recursive
b91 :: [Word] >>= [Word]
b91[t0] =
  t1 <- return t0
  b90[t1]

-----------------------------------------
-- not recursive
b93 :: [] >>= [Word]
b93[] =
  t0 <- return 1
  b91[t0]

-----------------------------------------
-- not recursive
b6 :: [Word, Word] >>= [Word]
b6[t0, t1] =
  add((t0, t1))

-----------------------------------------
-- not recursive
k4 :: {Word} [Word] ->> [Word]
k4{t0} t1 = b6[t0, t1]

-----------------------------------------
-- not recursive
b7 :: [Word] >>= [Word -> Word]
b7[t0] =
  t1 <- k4{t0}
  Func(t1)

-----------------------------------------
-- not recursive
k5 :: {} [Word] ->> [Word -> Word]
k5{} t0 = b7[t0]

-----------------------------------------
-- not recursive
b8 :: [] >>= [Word -> Word -> Word]
b8[] =
  t0 <- k5{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint add :: Word -> Word -> Word
add <-
  b8[]

-----------------------------------------
-- not recursive
b9 :: [Word, Word] >>= [Word]
b9[t0, t1] =
  sub((t0, t1))

-----------------------------------------
-- not recursive
k6 :: {Word} [Word] ->> [Word]
k6{t0} t1 = b9[t0, t1]

-----------------------------------------
-- not recursive
b10 :: [Word] >>= [Word -> Word]
b10[t0] =
  t1 <- k6{t0}
  Func(t1)

-----------------------------------------
-- not recursive
k7 :: {} [Word] ->> [Word -> Word]
k7{} t0 = b10[t0]

-----------------------------------------
-- not recursive
b11 :: [] >>= [Word -> Word -> Word]
b11[] =
  t0 <- k7{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint sub :: Word -> Word -> Word
sub <-
  b11[]

-----------------------------------------
-- not recursive
b0 :: forall (a :: tuple). [] >>= a
b0[] =
  halt(())

-----------------------------------------
-- recursive
b97 :: [] >>= [Word -> Word]
b97[] =
  t0 <- k55{}
  Func(t0)
k55 :: {} [Word] ->> [Word]
k55{} t0 = b96[t0]
b96 :: [Word] >>= [Word]
b96[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 0
  case t4 of
    True -> b95[]
    False -> b94[t0]
    _ -> b0[]
b94 :: [Word] >>= [Word]
b94[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 1
  case t4 of
    True -> b93[]
    False -> b92[t0]
    _ -> b0[]
b92 :: [Word] >>= [Word]
b92[t0] =
  t1 <- Func 0 add
  t2 <- Func 0 fib
  t3 <- Func 0 sub
  t4 <- t3 @ t0
  t5 <- Func 0 t4
  t6 <- t5 @ 1
  t7 <- t2 @ t6
  t8 <- t1 @ t7
  t9 <- Func 0 t8
  t10 <- Func 0 fib
  t11 <- Func 0 sub
  t12 <- t11 @ t0
  t13 <- Func 0 t12
  t14 <- t13 @ 2
  t15 <- t10 @ t14
  t16 <- t9 @ t15
  b91[t16]
fib :: Word -> Word
fib <-
  b97[]

-----------------------------------------
-- not recursive
b82 :: [Word] >>= [Word]
b82[t0] =
  return t0

-----------------------------------------
-- not recursive
b87 :: [] >>= [Word]
b87[] =
  t0 <- return 0
  b82[t0]

-----------------------------------------
-- not recursive
b83 :: [Word] >>= [Word]
b83[t0] =
  t1 <- return t0
  b82[t1]

-----------------------------------------
-- not recursive
b85 :: [] >>= [Word]
b85[] =
  t0 <- return 1
  b83[t0]

-----------------------------------------
-- not recursive
b84 :: [Word] >>= [Word]
b84[t0] =
  t1 <- Func 0 add
  t2 <- Func 0 fib
  t3 <- Func 0 sub
  t4 <- t3 @ t0
  t5 <- Func 0 t4
  t6 <- t5 @ 1
  t7 <- t2 @ t6
  t8 <- t1 @ t7
  t9 <- Func 0 t8
  t10 <- Func 0 fib
  t11 <- Func 0 sub
  t12 <- t11 @ t0
  t13 <- Func 0 t12
  t14 <- t13 @ 2
  t15 <- t10 @ t14
  t16 <- t9 @ t15
  b83[t16]

-----------------------------------------
-- not recursive
b86 :: [Word] >>= [Word]
b86[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 1
  case t4 of
    True -> b85[]
    False -> b84[t0]
    _ -> b0[]

-----------------------------------------
-- not recursive
b88 :: [Word] >>= [Word]
b88[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 0
  case t4 of
    True -> b87[]
    False -> b86[t0]
    _ -> b0[]

-----------------------------------------
-- not recursive
k54 :: {} [Word] ->> [Word]
k54{} t0 = b88[t0]

-----------------------------------------
-- not recursive
b89 :: [] >>= [Word -> Word]
b89[] =
  t0 <- k54{}
  Func(t0)

-----------------------------------------
-- not recursive
fib1 :: Word -> Word
fib1 <-
  b89[]

-----------------------------------------
-- not recursive
b76 :: [Word] >>= [Unit]
b76[t0] =
  [] <- printWord((t0))
  Unit()

-----------------------------------------
-- not recursive
entrypoint printWord1 :: {Word} [] ->> [Unit]
printWord1{t0} [] = b76[t0]

-----------------------------------------
-- not recursive
b74 :: [Word] >>= [Proc Unit]
b74[t0] =
  t1 <- printWord1{t0}
  Proc(t1)

-----------------------------------------
-- not recursive
k48 :: {} [Word] ->> [Proc Unit]
k48{} t0 = b74[t0]

-----------------------------------------
-- not recursive
b75 :: [] >>= [Word -> Proc Unit]
b75[] =
  t0 <- k48{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint printWord :: Word -> Proc Unit
printWord <-
  b75[]

-----------------------------------------
-- not recursive
b98 :: [] >>= [Unit]
b98[] =
  t0 <- Func 0 printWord
  t1 <- t0 @ 91
  t2 <- Proc 0 t1
  t3 <- t2 @ []
  t4 <- Func 0 printWord
  t5 <- Func 0 fib
  t6 <- t5 @ 12
  t7 <- t4 @ t6
  t8 <- Proc 0 t7
  t9 <- t8 @ []
  t10 <- Func 0 printWord
  t11 <- Func 0 fib1
  t12 <- t11 @ 12
  t13 <- t10 @ t12
  t14 <- Proc 0 t13
  t15 <- t14 @ []
  t16 <- Func 0 printWord
  t17 <- t16 @ 17
  t18 <- Proc 0 t17
  t18 @ []

-----------------------------------------
-- not recursive
k56 :: {} [] ->> [Unit]
k56{} [] = b98[]

-----------------------------------------
-- not recursive
b99 :: [] >>= [Proc Unit]
b99[] =
  t0 <- k56{}
  Proc(t0)

-----------------------------------------
-- not recursive
main :: Proc Unit
main <-
  b99[]

-----------------------------------------
-- Entrypoints:
