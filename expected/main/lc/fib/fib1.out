data -> (a :: *) (b :: *)
  = Func ([a] ->> [b])

bitdata Bool /1
  = False [ B0 ]
    -- predFalse(x :: Bit 1) = x == 0b0
  | True [ B1 ]
    -- predTrue(x :: Bit 1) = x == 0b1

-- bit pattern:
--  _

data Proc (a :: *)
  = Proc ([] ->> [a])

data Unit
  = Unit

-----------------------------------------
-- not recursive
b64 :: [Word] >>= [Unit]
b64[t0] =
  [] <- printWord((t0))
  Unit()

-----------------------------------------
-- not recursive
entrypoint printWord1 :: {Word} [] ->> [Unit]
printWord1{t0} [] = b64[t0]

-----------------------------------------
-- not recursive
b62 :: [Word] >>= [Proc Unit]
b62[t0] =
  t1 <- printWord1{t0}
  Proc(t1)

-----------------------------------------
-- not recursive
k40 :: {} [Word] ->> [Proc Unit]
k40{} t0 = b62[t0]

-----------------------------------------
-- not recursive
b63 :: [] >>= [Word -> Proc Unit]
b63[] =
  t0 <- k40{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint printWord :: Word -> Proc Unit
printWord <-
  b63[]

-----------------------------------------
-- not recursive
entrypoint false :: Bool
false <-
  False()

-----------------------------------------
-- not recursive
entrypoint bfalse :: [] >>= [Bool]
bfalse[] =
  return false

-----------------------------------------
-- not recursive
entrypoint true :: Bool
true <-
  True()

-----------------------------------------
-- not recursive
entrypoint btrue :: [] >>= [Bool]
btrue[] =
  return true

-----------------------------------------
-- not recursive
entrypoint bconv :: [Flag] >>= [Bool]
bconv[t0] =
  if t0
    then btrue[]
    else bfalse[]

-----------------------------------------
-- not recursive
b42 :: [Word, Word] >>= [Bool]
b42[t0, t1] =
  t2 <- primEq((t0, t1))
  bconv[t2]

-----------------------------------------
-- not recursive
k27 :: {Word} [Word] ->> [Bool]
k27{t0} t1 = b42[t0, t1]

-----------------------------------------
-- not recursive
b43 :: [Word] >>= [Word -> Bool]
b43[t0] =
  t1 <- k27{t0}
  Func(t1)

-----------------------------------------
-- not recursive
k28 :: {} [Word] ->> [Word -> Bool]
k28{} t0 = b43[t0]

-----------------------------------------
-- not recursive
b44 :: [] >>= [Word -> Word -> Bool]
b44[] =
  t0 <- k28{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint eq :: Word -> Word -> Bool
eq <-
  b44[]

-----------------------------------------
-- not recursive
b6 :: [Word, Word] >>= [Word]
b6[t0, t1] =
  add((t0, t1))

-----------------------------------------
-- not recursive
k4 :: {Word} [Word] ->> [Word]
k4{t0} t1 = b6[t0, t1]

-----------------------------------------
-- not recursive
b7 :: [Word] >>= [Word -> Word]
b7[t0] =
  t1 <- k4{t0}
  Func(t1)

-----------------------------------------
-- not recursive
k5 :: {} [Word] ->> [Word -> Word]
k5{} t0 = b7[t0]

-----------------------------------------
-- not recursive
b8 :: [] >>= [Word -> Word -> Word]
b8[] =
  t0 <- k5{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint add :: Word -> Word -> Word
add <-
  b8[]

-----------------------------------------
-- not recursive
b9 :: [Word, Word] >>= [Word]
b9[t0, t1] =
  sub((t0, t1))

-----------------------------------------
-- not recursive
k6 :: {Word} [Word] ->> [Word]
k6{t0} t1 = b9[t0, t1]

-----------------------------------------
-- not recursive
b10 :: [Word] >>= [Word -> Word]
b10[t0] =
  t1 <- k6{t0}
  Func(t1)

-----------------------------------------
-- not recursive
k7 :: {} [Word] ->> [Word -> Word]
k7{} t0 = b10[t0]

-----------------------------------------
-- not recursive
b11 :: [] >>= [Word -> Word -> Word]
b11[] =
  t0 <- k7{}
  Func(t0)

-----------------------------------------
-- not recursive
entrypoint sub :: Word -> Word -> Word
sub <-
  b11[]

-----------------------------------------
-- not recursive
b78 :: [Word] >>= [Word]
b78[t0] =
  return t0

-----------------------------------------
-- not recursive
b80 :: [Word] >>= [Word]
b80[t0] =
  t1 <- return t0
  b78[t1]

-----------------------------------------
-- not recursive
b81 :: [] >>= [Word]
b81[] =
  t0 <- return 1
  b80[t0]

-----------------------------------------
-- not recursive
b0 :: forall (a :: tuple). [] >>= a
b0[] =
  halt(())

-----------------------------------------
-- not recursive
b79 :: [] >>= [Word]
b79[] =
  t0 <- return 0
  b78[t0]

-----------------------------------------
-- recursive
b85 :: [] >>= [Word -> Word]
b85[] =
  t0 <- k47{}
  Func(t0)
k47 :: {} [Word] ->> [Word]
k47{} t0 = b84[t0]
b84 :: [Word] >>= [Word]
b84[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 0
  case t4 of
    True -> b79[]
    False -> b83[t0]
    _ -> b0[]
b83 :: [Word] >>= [Word]
b83[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 1
  case t4 of
    True -> b81[]
    False -> b82[t0]
    _ -> b0[]
b82 :: [Word] >>= [Word]
b82[t0] =
  t1 <- Func 0 add
  t2 <- Func 0 fib
  t3 <- Func 0 sub
  t4 <- t3 @ t0
  t5 <- Func 0 t4
  t6 <- t5 @ 1
  t7 <- t2 @ t6
  t8 <- t1 @ t7
  t9 <- Func 0 t8
  t10 <- Func 0 fib
  t11 <- Func 0 sub
  t12 <- t11 @ t0
  t13 <- Func 0 t12
  t14 <- t13 @ 2
  t15 <- t10 @ t14
  t16 <- t9 @ t15
  b80[t16]
fib :: Word -> Word
fib <-
  b85[]

-----------------------------------------
-- not recursive
b70 :: [Word] >>= [Word]
b70[t0] =
  return t0

-----------------------------------------
-- not recursive
b72 :: [Word] >>= [Word]
b72[t0] =
  t1 <- return t0
  b70[t1]

-----------------------------------------
-- not recursive
b74 :: [Word] >>= [Word]
b74[t0] =
  t1 <- Func 0 add
  t2 <- Func 0 fib
  t3 <- Func 0 sub
  t4 <- t3 @ t0
  t5 <- Func 0 t4
  t6 <- t5 @ 1
  t7 <- t2 @ t6
  t8 <- t1 @ t7
  t9 <- Func 0 t8
  t10 <- Func 0 fib
  t11 <- Func 0 sub
  t12 <- t11 @ t0
  t13 <- Func 0 t12
  t14 <- t13 @ 2
  t15 <- t10 @ t14
  t16 <- t9 @ t15
  b72[t16]

-----------------------------------------
-- not recursive
b73 :: [] >>= [Word]
b73[] =
  t0 <- return 1
  b72[t0]

-----------------------------------------
-- not recursive
b75 :: [Word] >>= [Word]
b75[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 1
  case t4 of
    True -> b73[]
    False -> b74[t0]
    _ -> b0[]

-----------------------------------------
-- not recursive
b71 :: [] >>= [Word]
b71[] =
  t0 <- return 0
  b70[t0]

-----------------------------------------
-- not recursive
b76 :: [Word] >>= [Word]
b76[t0] =
  t1 <- Func 0 eq
  t2 <- t1 @ t0
  t3 <- Func 0 t2
  t4 <- t3 @ 0
  case t4 of
    True -> b71[]
    False -> b75[t0]
    _ -> b0[]

-----------------------------------------
-- not recursive
k46 :: {} [Word] ->> [Word]
k46{} t0 = b76[t0]

-----------------------------------------
-- not recursive
b77 :: [] >>= [Word -> Word]
b77[] =
  t0 <- k46{}
  Func(t0)

-----------------------------------------
-- not recursive
fib1 :: Word -> Word
fib1 <-
  b77[]

-----------------------------------------
-- not recursive
b86 :: [] >>= [Unit]
b86[] =
  t0 <- Func 0 printWord
  t1 <- t0 @ 91
  t2 <- Proc 0 t1
  t3 <- t2 @ []
  t4 <- Func 0 printWord
  t5 <- Func 0 fib
  t6 <- t5 @ 12
  t7 <- t4 @ t6
  t8 <- Proc 0 t7
  t9 <- t8 @ []
  t10 <- Func 0 printWord
  t11 <- Func 0 fib1
  t12 <- t11 @ 12
  t13 <- t10 @ t12
  t14 <- Proc 0 t13
  t15 <- t14 @ []
  t16 <- Func 0 printWord
  t17 <- t16 @ 17
  t18 <- Proc 0 t17
  t18 @ []

-----------------------------------------
-- not recursive
k48 :: {} [] ->> [Unit]
k48{} [] = b86[]

-----------------------------------------
-- not recursive
b87 :: [] >>= [Proc Unit]
b87[] =
  t0 <- k48{}
  Proc(t0)

-----------------------------------------
-- not recursive
main :: Proc Unit
main <-
  b87[]

-----------------------------------------
-- Entrypoints:
