data ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330
  = Inl$jex1843 ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431
  | Inr$jey2248 Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jg91632

data ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125
  = Inl$jfk135 Word
  | Inr$jfl236 ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226

data ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822
  = Inl$jf81130 Word
  | Inr$jf91231 ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923

data ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834
  = Inl$jem2549 Word
  | Inr$jen2650 Sum_ExprLParenConstColonPlusColonSumRParen$jg31935

data ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431
  = Inl$jev1944 Word
  | Inr$jew2045 Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jg91632

data ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428
  = Inl$jfd640 Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527
  | Inr$jfe841 Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgn629

data ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226
  = Inl$jfg337 Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527
  | Inr$jfh539 ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428

data ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923
  = Inl$jf51332 Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgh1120
  | Inr$jf61533 Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgh1120

data Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgn629
  = Double$jfb942 Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024

data Expr_ConstColonPlusColonSum$jg41736
  = In$jek2452 ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834

data Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721
  = In$jfa1029 ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822

data Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024
  = In$jfi034 ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125

data Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233
  = In$jet1747 ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330

data Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527
  = Product$jfc738 Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024 Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024

data Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgh1120
  = Product$jf31628 Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721 Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721

data Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jg91632
  = Product$jer2346 Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233 Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233

data Sum_ExprLParenConstColonPlusColonSumRParen$jg31935
  = Sum$jej2751 Expr_ConstColonPlusColonSum$jg41736 Expr_ConstColonPlusColonSum$jg41736

data Unit
  = Unit

-----------------------------------------
-- not recursive
b1631 :: [ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834] >>= [Word]
b1631[t0] =
  assert t0 Inl$jem2549
  Inl$jem2549 0 t0

-----------------------------------------
-- recursive
b1206 :: [Expr_ConstColonPlusColonSum$jg41736] >>= [Word]
b1206[t0] =
  t1 <- In$jek2452 0 t0
  case t1 of
    Inl$jem2549 -> b1631[t1]
    Inr$jen2650 -> b1453[t1]
b1453 :: [ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834] >>= [Word]
b1453[t0] =
  assert t0 Inr$jen2650
  t1 <- Inr$jen2650 0 t0
  t2 <- Sum$jej2751 0 t1
  t3 <- Sum$jej2751 1 t1
  t4 <- b1206[t2]
  t5 <- b1206[t3]
  add((t4, t5))

-----------------------------------------
-- not recursive
s63 :: ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834
s63 <-
  Inl$jem2549(2)

-----------------------------------------
-- not recursive
s73 :: Expr_ConstColonPlusColonSum$jg41736
s73 <-
  In$jek2452(s63)

-----------------------------------------
-- not recursive
s62 :: ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834
s62 <-
  Inl$jem2549(1)

-----------------------------------------
-- not recursive
s72 :: Expr_ConstColonPlusColonSum$jg41736
s72 <-
  In$jek2452(s62)

-----------------------------------------
-- not recursive
s82 :: Sum_ExprLParenConstColonPlusColonSumRParen$jg31935
s82 <-
  Sum$jej2751(s72, s73)

-----------------------------------------
-- not recursive
s88 :: ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834
s88 <-
  Inr$jen2650(s82)

-----------------------------------------
-- not recursive
x :: Word
x <-
  b1453[s88]

-----------------------------------------
-- not recursive
b1632 :: [ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431] >>= [Word]
b1632[t0] =
  assert t0 Inl$jev1944
  Inl$jev1944 0 t0

-----------------------------------------
-- recursive
b1459 :: [ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330] >>= [Word]
b1459[t0] =
  assert t0 Inr$jey2248
  t1 <- Inr$jey2248 0 t0
  t2 <- Product$jer2346 0 t1
  t3 <- Product$jer2346 1 t1
  t4 <- b1215[t2]
  t5 <- b1215[t3]
  mul((t4, t5))
b1458 :: [ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431] >>= [Word]
b1458[t0] =
  assert t0 Inr$jew2045
  t1 <- Inr$jew2045 0 t0
  t2 <- Product$jer2346 0 t1
  t3 <- Product$jer2346 1 t1
  t4 <- b1215[t2]
  t5 <- b1215[t3]
  add((t4, t5))
b1215 :: [Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233] >>= [Word]
b1215[t0] =
  t1 <- In$jet1747 0 t0
  case t1 of
    Inl$jex1843 -> b1456[t1]
    Inr$jey2248 -> b1459[t1]
b1456 :: [ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330] >>= [Word]
b1456[t0] =
  assert t0 Inl$jex1843
  t1 <- Inl$jex1843 0 t0
  case t1 of
    Inl$jev1944 -> b1632[t1]
    Inr$jew2045 -> b1458[t1]

-----------------------------------------
-- not recursive
s66 :: ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431
s66 <-
  Inl$jev1944(3)

-----------------------------------------
-- not recursive
s76 :: ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330
s76 <-
  Inl$jex1843(s66)

-----------------------------------------
-- not recursive
s85 :: Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233
s85 <-
  In$jet1747(s76)

-----------------------------------------
-- not recursive
s65 :: ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431
s65 <-
  Inl$jev1944(2)

-----------------------------------------
-- not recursive
s75 :: ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330
s75 <-
  Inl$jex1843(s65)

-----------------------------------------
-- not recursive
s84 :: Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233
s84 <-
  In$jet1747(s75)

-----------------------------------------
-- not recursive
s89 :: Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jg91632
s89 <-
  Product$jer2346(s84, s85)

-----------------------------------------
-- not recursive
s92 :: ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330
s92 <-
  Inr$jey2248(s89)

-----------------------------------------
-- not recursive
s95 :: Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233
s95 <-
  In$jet1747(s92)

-----------------------------------------
-- not recursive
s64 :: ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431
s64 <-
  Inl$jev1944(1)

-----------------------------------------
-- not recursive
s74 :: ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330
s74 <-
  Inl$jex1843(s64)

-----------------------------------------
-- not recursive
s83 :: Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233
s83 <-
  In$jet1747(s74)

-----------------------------------------
-- not recursive
s98 :: Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jg91632
s98 <-
  Product$jer2346(s83, s95)

-----------------------------------------
-- not recursive
s101 :: ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431
s101 <-
  Inr$jew2045(s98)

-----------------------------------------
-- not recursive
s104 :: ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330
s104 <-
  Inl$jex1843(s101)

-----------------------------------------
-- not recursive
y :: Word
y <-
  b1456[s104]

-----------------------------------------
-- not recursive
b1633 :: [ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822] >>= [Word]
b1633[t0] =
  assert t0 Inl$jf81130
  Inl$jf81130 0 t0

-----------------------------------------
-- recursive
b1466 :: [ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923] >>= [Word]
b1466[t0] =
  assert t0 Inl$jf51332
  t1 <- Inl$jf51332 0 t0
  t2 <- Product$jf31628 0 t1
  t3 <- Product$jf31628 1 t1
  t4 <- b1220[t2]
  t5 <- b1220[t3]
  add((t4, t5))
b1467 :: [ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923] >>= [Word]
b1467[t0] =
  assert t0 Inr$jf61533
  t1 <- Inr$jf61533 0 t0
  t2 <- Product$jf31628 0 t1
  t3 <- Product$jf31628 1 t1
  t4 <- b1220[t2]
  t5 <- b1220[t3]
  mul((t4, t5))
b1220 :: [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721] >>= [Word]
b1220[t0] =
  t1 <- In$jfa1029 0 t0
  case t1 of
    Inl$jf81130 -> b1633[t1]
    Inr$jf91231 -> b1465[t1]
b1465 :: [ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822] >>= [Word]
b1465[t0] =
  assert t0 Inr$jf91231
  t1 <- Inr$jf91231 0 t0
  case t1 of
    Inl$jf51332 -> b1466[t1]
    Inr$jf61533 -> b1467[t1]

-----------------------------------------
-- not recursive
s69 :: ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822
s69 <-
  Inl$jf81130(3)

-----------------------------------------
-- not recursive
s79 :: Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721
s79 <-
  In$jfa1029(s69)

-----------------------------------------
-- not recursive
s68 :: ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822
s68 <-
  Inl$jf81130(2)

-----------------------------------------
-- not recursive
s78 :: Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721
s78 <-
  In$jfa1029(s68)

-----------------------------------------
-- not recursive
s86 :: Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgh1120
s86 <-
  Product$jf31628(s78, s79)

-----------------------------------------
-- not recursive
s90 :: ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923
s90 <-
  Inr$jf61533(s86)

-----------------------------------------
-- not recursive
s93 :: ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822
s93 <-
  Inr$jf91231(s90)

-----------------------------------------
-- not recursive
s96 :: Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721
s96 <-
  In$jfa1029(s93)

-----------------------------------------
-- not recursive
s67 :: ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822
s67 <-
  Inl$jf81130(1)

-----------------------------------------
-- not recursive
s77 :: Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721
s77 <-
  In$jfa1029(s67)

-----------------------------------------
-- not recursive
s99 :: Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgh1120
s99 <-
  Product$jf31628(s77, s96)

-----------------------------------------
-- not recursive
s102 :: ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923
s102 <-
  Inl$jf51332(s99)

-----------------------------------------
-- not recursive
s105 :: ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822
s105 <-
  Inr$jf91231(s102)

-----------------------------------------
-- not recursive
z :: Word
z <-
  b1465[s105]

-----------------------------------------
-- not recursive
b998 :: [] >>= [Word]
b998[] =
  return 0

-----------------------------------------
-- recursive
b1395 :: [Word, Word, Word] >>= [Word]
b1395[t0, t1, t2] =
  t3 <- primEq((t0, t1))
  if t3
    then b1390[t2, t0]
    else b1397[t0, t1, t2]
b1397 :: [Word, Word, Word] >>= [Word]
b1397[t0, t1, t2] =
  t3 <- primUle((t0, t1))
  if t3
    then b1399[t1, t0, t2]
    else b1390[t2, t0]
b1399 :: [Word, Word, Word] >>= [Word]
b1399[t0, t1, t2] =
  t3 <- mul((t1, 10))
  b1394[t3, t0, t2]
b1393 :: [Word, Word, Word] >>= [Word]
b1393[t0, t1, t2] =
  t3 <- mul((t2, 10))
  b1394[t3, t1, t0]
b1394 :: [Word, Word, Word] >>= [Word]
b1394[t0, t1, t2] =
  t3 <- mul((t0, 100))
  t4 <- primUge((t2, t3))
  if t4
    then b1395[t0, t1, t2]
    else b1390[t2, t0]
b1391 :: [Word, Word, Word] >>= [Word]
b1391[t0, t1, t2] =
  t3 <- primUle((t0, t1))
  if t3
    then b1393[t2, t1, t0]
    else b1390[t2, t0]
b1389 :: [Word, Word, Word] >>= [Word]
b1389[t0, t1, t2] =
  t3 <- primEq((t1, t0))
  if t3
    then b1390[t2, t1]
    else b1391[t1, t0, t2]
b1388 :: [Word, Word] >>= [Word]
b1388[t0, t1] =
  t2 <- primUge((t0, 100))
  if t2
    then b1389[t1, 1, t0]
    else b1390[t0, 1]
b1390 :: [Word, Word] >>= [Word]
b1390[t0, t1] =
  t2 <- mul((t1, 10))
  t3 <- sub((t0, t2))
  t4 <- b1387[t3]
  add((t1, t4))
b1387 :: [Word] >>= [Word]
b1387[t0] =
  t1 <- primUlt((t0, 10))
  if t1
    then b998[]
    else b1388[t0, 10000000]

-----------------------------------------
-- not recursive
Proxy$je5 :: Unit
Proxy$je5 <-
  Unit()

-----------------------------------------
-- not recursive
b1289 :: [Word] >>= [Unit]
b1289[t0] =
  t1 <- add((t0, 48))
  t2 <- putchar((t1))
  return Proxy$je5

-----------------------------------------
-- recursive
b1252 :: [Word, Word, Word] >>= [Word]
b1252[t0, t1, t2] =
  t3 <- primEq((t0, t1))
  if t3
    then b1390[t2, t0]
    else b1405[t0, t1, t2]
b1405 :: [Word, Word, Word] >>= [Word]
b1405[t0, t1, t2] =
  t3 <- primUle((t0, t1))
  if t3
    then b1257[t1, t0, t2]
    else b1390[t2, t0]
b1257 :: [Word, Word, Word] >>= [Word]
b1257[t0, t1, t2] =
  t3 <- mul((t1, 10))
  b1251[t3, t0, t2]
b1251 :: [Word, Word, Word] >>= [Word]
b1251[t0, t1, t2] =
  t3 <- mul((t0, 100))
  t4 <- primUge((t2, t3))
  if t4
    then b1252[t0, t1, t2]
    else b1390[t2, t0]

-----------------------------------------
-- recursive
b1497 :: [Word, Word] >>= [Unit]
b1497[t0, t1] =
  t2 <- mul((t1, 10))
  t3 <- sub((t0, t2))
  t4 <- b1387[t3]
  t5 <- add((t1, t4))
  b1419[t0, t5]
b1419 :: [Word, Word] >>= [Unit]
b1419[t0, t1] =
  t2 <- b1288[t1]
  t3 <- rem((t0, 10))
  b1288[t3]
b1547 :: [Word, Word] >>= [Unit]
b1547[t0, t1] =
  t2 <- mul((t1, 10))
  t3 <- sub((t0, t2))
  t4 <- b1387[t3]
  t5 <- add((t1, t4))
  b1501[t5, t0]
b1501 :: [Word, Word] >>= [Unit]
b1501[t0, t1] =
  t2 <- b1288[t0]
  t3 <- rem((t1, 10))
  b1288[t3]
b1288 :: [Word] >>= [Unit]
b1288[t0] =
  t1 <- primUlt((t0, 10))
  if t1
    then b1289[t0]
    else b1426[t0]
b1426 :: [Word] >>= [Unit]
b1426[t0] =
  t1 <- primUlt((t0, 10))
  if t1
    then b1419[t0, 0]
    else b1472[t0, 10000000]
b1472 :: [Word, Word] >>= [Unit]
b1472[t0, t1] =
  t2 <- primUge((t0, 100))
  if t2
    then b1496[t1, 1, t0]
    else b1497[t0, 1]
b1496 :: [Word, Word, Word] >>= [Unit]
b1496[t0, t1, t2] =
  t3 <- primEq((t1, t0))
  if t3
    then b1497[t2, t1]
    else b1528[t1, t0, t2]
b1528 :: [Word, Word, Word] >>= [Unit]
b1528[t0, t1, t2] =
  t3 <- primUle((t0, t1))
  if t3
    then b1545[t2, t1, t0]
    else b1497[t2, t0]
b1545 :: [Word, Word, Word] >>= [Unit]
b1545[t0, t1, t2] =
  t3 <- mul((t2, 10))
  t4 <- b1394[t3, t1, t0]
  t5 <- b1089[t4]
  t6 <- rem((t0, 10))
  b1288[t6]
b1507 :: [Word] >>= [Unit]
b1507[t0] =
  t1 <- primUlt((t0, 10))
  if t1
    then b1501[0, t0]
    else b1529[t0, 10000000]
b1529 :: [Word, Word] >>= [Unit]
b1529[t0, t1] =
  t2 <- primUge((t0, 100))
  if t2
    then b1546[t1, 1, t0]
    else b1547[t0, 1]
b1546 :: [Word, Word, Word] >>= [Unit]
b1546[t0, t1, t2] =
  t3 <- primEq((t1, t0))
  if t3
    then b1547[t2, t1]
    else b1564[t1, t0, t2]
b1564 :: [Word, Word, Word] >>= [Unit]
b1564[t0, t1, t2] =
  t3 <- primUle((t0, t1))
  if t3
    then b1572[t2, t1, t0]
    else b1547[t2, t0]
b1572 :: [Word, Word, Word] >>= [Unit]
b1572[t0, t1, t2] =
  t3 <- mul((t2, 10))
  t4 <- b1251[t3, t1, t0]
  t5 <- b1089[t4]
  t6 <- rem((t0, 10))
  b1288[t6]
b1089 :: [Word] >>= [Unit]
b1089[t0] =
  t1 <- primUlt((t0, 10))
  if t1
    then b1289[t0]
    else b1507[t0]

-----------------------------------------
-- not recursive
b1640 :: [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1640[t0] =
  assert t0 Inl$jfk135
  t1 <- Inl$jfk135 0 t0
  t2 <- Inl$jf81130(t1)
  In$jfa1029(t2)

-----------------------------------------
-- not recursive
k485 :: {ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822} [[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
k485{t0} t1 = In$jfa1029(t0)

-----------------------------------------
-- not recursive
b1638 :: [ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226, [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1638[t0, t1] =
  assert t0 Inr$jfh539
  t2 <- Inr$jfh539 0 t0
  t1 @ t2

-----------------------------------------
-- not recursive
b1293 :: [Word] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1293[t0] =
  t1 <- Inl$jf81130(t0)
  In$jfa1029(t1)

-----------------------------------------
-- not recursive
k500 :: {Word} [[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
k500{t0} t1 = b1293[t0]

-----------------------------------------
-- not recursive
b1636 :: [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1636[t0] =
  assert t0 Inl$jfk135
  t1 <- Inl$jfk135 0 t0
  k500{t1}

-----------------------------------------
-- not recursive
b1637 :: [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125, [ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1637[t0, t1] =
  assert t0 Inr$jfl236
  t2 <- Inr$jfl236 0 t0
  t1 @ t2

-----------------------------------------
-- not recursive
b1291 :: [[ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]], ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1291[t0, t1] =
  case t1 of
    Inl$jfk135 -> b1636[t1]
    Inr$jfl236 -> b1637[t1, t0]

-----------------------------------------
-- not recursive
k489 :: {[ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]} [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
k489{t0} t1 = b1291[t0, t1]

-----------------------------------------
-- recursive
k109 :: {[ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]} [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
k109{t0} t1 = b167[t1, t0]
b167 :: [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024, [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b167[t0, t1] =
  t2 <- k109{t1}
  t3 <- In$jfi034 0 t0
  t4 <- t1 @ t3
  t4 @ t2

-----------------------------------------
-- not recursive
b903 :: [Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgn629, [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b903[t0, t1] =
  t2 <- Double$jfb942 0 t0
  t3 <- t1 @ t2
  t4 <- t1 @ t2
  t5 <- Product$jf31628(t3, t4)
  t6 <- Inl$jf51332(t5)
  t7 <- Inr$jf91231(t6)
  In$jfa1029(t7)

-----------------------------------------
-- not recursive
k384 :: {Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgn629} [[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
k384{t0} t1 = b903[t0, t1]

-----------------------------------------
-- not recursive
b1639 :: [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1639[t0] =
  assert t0 Inr$jfe841
  t1 <- Inr$jfe841 0 t0
  k384{t1}

-----------------------------------------
-- recursive
k488 :: {[ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]} [ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
k488{t0} t1 = b1294[t0, t1]
b1294 :: [[ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]], ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1294[t0, t1] =
  case t1 of
    Inl$jfg337 -> b1295[t1]
    Inr$jfh539 -> b1638[t1, t0]
b1295 :: [ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1295[t0] =
  assert t0 Inl$jfg337
  t1 <- Inl$jfg337 0 t0
  t2 <- b1306[t1]
  k485{t2}
b1306 :: [Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527] >>= [ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822]
b1306[t0] =
  t1 <- b1307[t0]
  Inr$jf91231(t1)
b1307 :: [Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527] >>= [ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923]
b1307[t0] =
  t1 <- Product$jfc738 0 t0
  t2 <- Product$jfc738 1 t0
  t3 <- b908[t1]
  t4 <- b908[t2]
  t5 <- Product$jf31628(t3, t4)
  Inl$jf51332(t5)
k487 :: {} [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
k487{} t0 = b1182[t0]
b1182 :: [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1182[t0] =
  case t0 of
    Inl$jfd640 -> b1311[t0]
    Inr$jfe841 -> b1639[t0]
b1311 :: [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] >>= [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
b1311[t0] =
  assert t0 Inl$jfd640
  t1 <- Inl$jfd640 0 t0
  t2 <- b1318[t1]
  k485{t2}
b1318 :: [Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527] >>= [ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822]
b1318[t0] =
  t1 <- b1319[t0]
  Inr$jf91231(t1)
b1319 :: [Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527] >>= [ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923]
b1319[t0] =
  t1 <- Product$jfc738 0 t0
  t2 <- Product$jfc738 1 t0
  t3 <- b908[t1]
  t4 <- b908[t2]
  t5 <- Product$jf31628(t3, t4)
  Inr$jf61533(t5)
b908 :: [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b908[t0] =
  t1 <- b1179[]
  b167[t0, t1]
b1179 :: [] >>= [[ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]]
b1179[] =
  t0 <- b1180[]
  k489{t0}
b1180 :: [] >>= [[ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]]
b1180[] =
  t0 <- b1181[]
  k488{t0}
b1181 :: [] >>= [[ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]]
b1181[] =
  return s41
s41 :: [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
s41 <-
  k487{}

-----------------------------------------
-- not recursive
b1641 :: [ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226, [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]], [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1641[t0, t1, t2] =
  assert t0 Inr$jfh539
  t3 <- Inr$jfh539 0 t0
  t4 <- t1 @ t3
  t4 @ t2

-----------------------------------------
-- recursive
k512 :: {[ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]} [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
k512{t0} t1 = b1531[t1, t0]
b1531 :: [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024, [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1531[t0, t1] =
  t2 <- k512{t1}
  t3 <- In$jfi034 0 t0
  case t3 of
    Inl$jfk135 -> b1640[t3]
    Inr$jfl236 -> b1548[t3, t1, t2]
b1473 :: [ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1473[t0] =
  assert t0 Inl$jfg337
  t1 <- Inl$jfg337 0 t0
  t2 <- Product$jfc738 0 t1
  t3 <- Product$jfc738 1 t1
  t4 <- k512{s41}
  t5 <- In$jfi034 0 t2
  t6 <- b1522[s41, t5, t4]
  t7 <- In$jfi034 0 t3
  t8 <- b1522[s41, t7, t4]
  t9 <- Product$jf31628(t6, t8)
  t10 <- Inl$jf51332(t9)
  t11 <- Inr$jf91231(t10)
  In$jfa1029(t11)
b1522 :: [[ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]], ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125, [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1522[t0, t1, t2] =
  case t1 of
    Inl$jfk135 -> b1640[t1]
    Inr$jfl236 -> b1548[t1, t0, t2]
b1548 :: [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125, [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]], [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1548[t0, t1, t2] =
  assert t0 Inr$jfl236
  t3 <- Inr$jfl236 0 t0
  b1445[t1, t3, t2]
b1445 :: [[ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]], ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226, [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1445[t0, t1, t2] =
  case t1 of
    Inl$jfg337 -> b1473[t1]
    Inr$jfh539 -> b1641[t1, t0, t2]

-----------------------------------------
-- recursive
b1553 :: [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1553[t0] =
  assert t0 Inr$jfl236
  t1 <- Inr$jfl236 0 t0
  b1445[s41, t1, s60]
s60 :: [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
s60 <-
  k513{}
k513 :: {} [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
k513{} t0 = b1534[t0]
b1534 :: [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] >>= [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
b1534[t0] =
  t1 <- In$jfi034 0 t0
  case t1 of
    Inl$jfk135 -> b1640[t1]
    Inr$jfl236 -> b1553[t1]

-----------------------------------------
-- not recursive
s71 :: ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125
s71 <-
  Inl$jfk135(2)

-----------------------------------------
-- not recursive
s81 :: Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024
s81 <-
  In$jfi034(s71)

-----------------------------------------
-- not recursive
b910 :: [] >>= [Word]
b910[] =
  t0 <- b1534[s81]
  t1 <- b1534[s81]
  t2 <- Product$jf31628(t0, t1)
  t3 <- Inl$jf51332(t2)
  t4 <- Inr$jf91231(t3)
  t5 <- In$jfa1029(t4)
  t6 <- b1220[s77]
  t7 <- b1220[t5]
  add((t6, t7))

-----------------------------------------
-- not recursive
w :: Word
w <-
  b910[]

-----------------------------------------
-- not recursive
b911 :: [] >>= [Unit]
b911[] =
  t0 <- b1089[x]
  t1 <- b1089[y]
  t2 <- b1089[z]
  b1089[w]

-----------------------------------------
-- not recursive
main :: [] >>= [Unit]
main[] =
  b911[]

-----------------------------------------
-- not recursive
initialize :: [] >>= [Unit]
initialize[] =
  main[]

-----------------------------------------
-- Entrypoints:
; layout for Inl$jem2549
%dt0 = type {i32, i32}

; data layout for values of type ColonPlusColon_Const_Sum_ExprLParenConstColonPlusColonSumRParen$jg61834
%dt1 = type {i32}

@layout.0 = private constant %dt0 {i32 0, i32 2}

@val.1 = internal alias %dt1, %dt1* bitcast(%dt0* @layout.0 to %dt1*)

; layout for In$jek2452
%dt2 = type {i32, %dt1*}

; data layout for values of type Expr_ConstColonPlusColonSum$jg41736
%dt3 = type {i32}

@layout.2 = private constant %dt2 {i32 0, %dt1* @val.1}

@val.3 = internal alias %dt3, %dt3* bitcast(%dt2* @layout.2 to %dt3*)

@layout.4 = private constant %dt0 {i32 0, i32 1}

@val.5 = internal alias %dt1, %dt1* bitcast(%dt0* @layout.4 to %dt1*)

@layout.6 = private constant %dt2 {i32 0, %dt1* @val.5}

@val.7 = internal alias %dt3, %dt3* bitcast(%dt2* @layout.6 to %dt3*)

; layout for Sum$jej2751
%dt4 = type {i32, %dt3*, %dt3*}

; data layout for values of type Sum_ExprLParenConstColonPlusColonSumRParen$jg31935
%dt5 = type {i32}

@layout.8 = private constant %dt4 {i32 0, %dt3* @val.7, %dt3* @val.3}

@val.9 = internal alias %dt5, %dt5* bitcast(%dt4* @layout.8 to %dt5*)

; layout for Inr$jen2650
%dt6 = type {i32, %dt5*}

@layout.10 = private constant %dt6 {i32 1, %dt5* @val.9}

@val.11 = internal alias %dt1, %dt1* bitcast(%dt6* @layout.10 to %dt1*)

@x = internal global i32 0

; layout for Inl$jev1944
%dt7 = type {i32, i32}

; data layout for values of type ColonPlusColon_Const_Sum_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jgd1431
%dt8 = type {i32}

@layout.12 = private constant %dt7 {i32 0, i32 3}

@val.13 = internal alias %dt8, %dt8* bitcast(%dt7* @layout.12 to %dt8*)

; layout for Inl$jex1843
%dt9 = type {i32, %dt8*}

; data layout for values of type ColonPlusColon_ConstColonPlusColonSum_Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jge1330
%dt10 = type {i32}

@layout.14 = private constant %dt9 {i32 0, %dt8* @val.13}

@val.15 = internal alias %dt10, %dt10* bitcast(%dt9* @layout.14 to %dt10*)

; layout for In$jet1747
%dt11 = type {i32, %dt10*}

; data layout for values of type Expr_LParenConstColonPlusColonSumRParenColonPlusColonProduct$jgb1233
%dt12 = type {i32}

@layout.16 = private constant %dt11 {i32 0, %dt10* @val.15}

@val.17 = internal alias %dt12, %dt12* bitcast(%dt11* @layout.16 to %dt12*)

@layout.18 = private constant %dt7 {i32 0, i32 2}

@val.19 = internal alias %dt8, %dt8* bitcast(%dt7* @layout.18 to %dt8*)

@layout.20 = private constant %dt9 {i32 0, %dt8* @val.19}

@val.21 = internal alias %dt10, %dt10* bitcast(%dt9* @layout.20 to %dt10*)

@layout.22 = private constant %dt11 {i32 0, %dt10* @val.21}

@val.23 = internal alias %dt12, %dt12* bitcast(%dt11* @layout.22 to %dt12*)

; layout for Product$jer2346
%dt13 = type {i32, %dt12*, %dt12*}

; data layout for values of type Product_ExprLParenLParenConstColonPlusColonSumRParenColonPlusColonProductRParen$jg91632
%dt14 = type {i32}

@layout.24 = private constant %dt13 {i32 0, %dt12* @val.23, %dt12* @val.17}

@val.25 = internal alias %dt14, %dt14* bitcast(%dt13* @layout.24 to %dt14*)

; layout for Inr$jey2248
%dt15 = type {i32, %dt14*}

@layout.26 = private constant %dt15 {i32 1, %dt14* @val.25}

@val.27 = internal alias %dt10, %dt10* bitcast(%dt15* @layout.26 to %dt10*)

@layout.28 = private constant %dt11 {i32 0, %dt10* @val.27}

@val.29 = internal alias %dt12, %dt12* bitcast(%dt11* @layout.28 to %dt12*)

@layout.30 = private constant %dt7 {i32 0, i32 1}

@val.31 = internal alias %dt8, %dt8* bitcast(%dt7* @layout.30 to %dt8*)

@layout.32 = private constant %dt9 {i32 0, %dt8* @val.31}

@val.33 = internal alias %dt10, %dt10* bitcast(%dt9* @layout.32 to %dt10*)

@layout.34 = private constant %dt11 {i32 0, %dt10* @val.33}

@val.35 = internal alias %dt12, %dt12* bitcast(%dt11* @layout.34 to %dt12*)

@layout.36 = private constant %dt13 {i32 0, %dt12* @val.35, %dt12* @val.29}

@val.37 = internal alias %dt14, %dt14* bitcast(%dt13* @layout.36 to %dt14*)

; layout for Inr$jew2045
%dt16 = type {i32, %dt14*}

@layout.38 = private constant %dt16 {i32 1, %dt14* @val.37}

@val.39 = internal alias %dt8, %dt8* bitcast(%dt16* @layout.38 to %dt8*)

@layout.40 = private constant %dt9 {i32 0, %dt8* @val.39}

@val.41 = internal alias %dt10, %dt10* bitcast(%dt9* @layout.40 to %dt10*)

@y = internal global i32 0

; layout for Inl$jf81130
%dt17 = type {i32, i32}

; data layout for values of type ColonPlusColon_Const_SumColonPlusColonProduct_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgl822
%dt18 = type {i32}

@layout.42 = private constant %dt17 {i32 0, i32 3}

@val.43 = internal alias %dt18, %dt18* bitcast(%dt17* @layout.42 to %dt18*)

; layout for In$jfa1029
%dt19 = type {i32, %dt18*}

; data layout for values of type Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721
%dt20 = type {i32}

@layout.44 = private constant %dt19 {i32 0, %dt18* @val.43}

@val.45 = internal alias %dt20, %dt20* bitcast(%dt19* @layout.44 to %dt20*)

@layout.46 = private constant %dt17 {i32 0, i32 2}

@val.47 = internal alias %dt18, %dt18* bitcast(%dt17* @layout.46 to %dt18*)

@layout.48 = private constant %dt19 {i32 0, %dt18* @val.47}

@val.49 = internal alias %dt20, %dt20* bitcast(%dt19* @layout.48 to %dt20*)

; layout for Product$jf31628
%dt21 = type {i32, %dt20*, %dt20*}

; data layout for values of type Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgh1120
%dt22 = type {i32}

@layout.50 = private constant %dt21 {i32 0, %dt20* @val.49, %dt20* @val.45}

@val.51 = internal alias %dt22, %dt22* bitcast(%dt21* @layout.50 to %dt22*)

; layout for Inr$jf61533
%dt23 = type {i32, %dt22*}

; data layout for values of type ColonPlusColon_Sum_Product_ExprLParenConstColonPlusColonSumColonPlusColonProductRParen$jgj923
%dt24 = type {i32}

@layout.52 = private constant %dt23 {i32 1, %dt22* @val.51}

@val.53 = internal alias %dt24, %dt24* bitcast(%dt23* @layout.52 to %dt24*)

; layout for Inr$jf91231
%dt25 = type {i32, %dt24*}

@layout.54 = private constant %dt25 {i32 1, %dt24* @val.53}

@val.55 = internal alias %dt18, %dt18* bitcast(%dt25* @layout.54 to %dt18*)

@layout.56 = private constant %dt19 {i32 0, %dt18* @val.55}

@val.57 = internal alias %dt20, %dt20* bitcast(%dt19* @layout.56 to %dt20*)

@layout.58 = private constant %dt17 {i32 0, i32 1}

@val.59 = internal alias %dt18, %dt18* bitcast(%dt17* @layout.58 to %dt18*)

@layout.60 = private constant %dt19 {i32 0, %dt18* @val.59}

@val.61 = internal alias %dt20, %dt20* bitcast(%dt19* @layout.60 to %dt20*)

@layout.62 = private constant %dt21 {i32 0, %dt20* @val.61, %dt20* @val.57}

@val.63 = internal alias %dt22, %dt22* bitcast(%dt21* @layout.62 to %dt22*)

; layout for Inl$jf51332
%dt26 = type {i32, %dt22*}

@layout.64 = private constant %dt26 {i32 0, %dt22* @val.63}

@val.65 = internal alias %dt24, %dt24* bitcast(%dt26* @layout.64 to %dt24*)

@layout.66 = private constant %dt25 {i32 1, %dt24* @val.65}

@val.67 = internal alias %dt18, %dt18* bitcast(%dt25* @layout.66 to %dt18*)

@z = internal global i32 0

; data layout for values of type ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428
%dt29 = type {i32}

; data layout for values of type Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024
%dt34 = type {i32}

; closure types for [Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
%dt32 = type %dt20* (%dt33*, %dt34*)*

%dt33 = type {%dt32}

; closure types for [[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]
%dt30 = type %dt20* (%dt31*, %dt33*)*

%dt31 = type {%dt30}

; closure types for [ColonPlusColon_Product_Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgp428] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
%dt27 = type %dt31* (%dt28*, %dt29*)*

%dt28 = type {%dt27}

; layout for k487
%dt35 = type {%dt27}

@layout.68 = private constant %dt35 {%dt27 @clos_k487}

@val.69 = internal alias %dt28, %dt28* bitcast(%dt35* @layout.68 to %dt28*)

; layout for k513
%dt36 = type {%dt32}

@layout.70 = private constant %dt36 {%dt32 @clos_k513}

@val.71 = internal alias %dt33, %dt33* bitcast(%dt36* @layout.70 to %dt33*)

; layout for Inl$jfk135
%dt37 = type {i32, i32}

; data layout for values of type ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125
%dt38 = type {i32}

@layout.72 = private constant %dt37 {i32 0, i32 2}

@val.73 = internal alias %dt38, %dt38* bitcast(%dt37* @layout.72 to %dt38*)

; layout for In$jfi034
%dt39 = type {i32, %dt38*}

@layout.74 = private constant %dt39 {i32 0, %dt38* @val.73}

@val.75 = internal alias %dt34, %dt34* bitcast(%dt39* @layout.74 to %dt34*)

@w = internal global i32 0

define internal i32 @func_b1206(%dt3* %r0) {
  br label %b1206

b1206:
  %r4 = bitcast %dt3* %r0 to %dt2*
  %r5 = getelementptr inbounds %dt2, %dt2* %r4, i32 0, i32 1
  %r3 = load %dt1*, %dt1** %r5
  ; read the tag for a data object
  %r2 = getelementptr inbounds %dt1, %dt1* %r3, i32 0, i32 0
  %r1 = load i32, i32* %r2
  ; branch based on the tag value
  switch i32 %r1, label %b1453 [
      i32 0, label %b1631 ]

b1453:
  %r16 = bitcast %dt1* %r3 to %dt6*
  %r17 = getelementptr inbounds %dt6, %dt6* %r16, i32 0, i32 1
  %r13 = load %dt5*, %dt5** %r17
  %r14 = bitcast %dt5* %r13 to %dt4*
  %r15 = getelementptr inbounds %dt4, %dt4* %r14, i32 0, i32 1
  %r10 = load %dt3*, %dt3** %r15
  %r11 = bitcast %dt5* %r13 to %dt4*
  %r12 = getelementptr inbounds %dt4, %dt4* %r11, i32 0, i32 2
  %r9 = load %dt3*, %dt3** %r12
  %r7 = call i32 @func_b1206(%dt3* %r10)
  %r8 = call i32 @func_b1206(%dt3* %r9)
  %r6 = add i32 %r7, %r8
  ret i32 %r6

b1631:
  %r19 = bitcast %dt1* %r3 to %dt0*
  %r20 = getelementptr inbounds %dt0, %dt0* %r19, i32 0, i32 1
  %r18 = load i32, i32* %r20
  ret i32 %r18
}

define internal i32 @func_b1453(%dt1* %r0) {
  br label %b1453

b1453:
  %r11 = bitcast %dt1* %r0 to %dt6*
  %r12 = getelementptr inbounds %dt6, %dt6* %r11, i32 0, i32 1
  %r8 = load %dt5*, %dt5** %r12
  %r9 = bitcast %dt5* %r8 to %dt4*
  %r10 = getelementptr inbounds %dt4, %dt4* %r9, i32 0, i32 1
  %r5 = load %dt3*, %dt3** %r10
  %r6 = bitcast %dt5* %r8 to %dt4*
  %r7 = getelementptr inbounds %dt4, %dt4* %r6, i32 0, i32 2
  %r4 = load %dt3*, %dt3** %r7
  %r2 = call i32 @func_b1206(%dt3* %r5)
  %r3 = call i32 @func_b1206(%dt3* %r4)
  %r1 = add i32 %r2, %r3
  ret i32 %r1
}

define internal i32 @func_b1215(%dt12* %r0) {
  br label %b1215

b1215:
  %r4 = bitcast %dt12* %r0 to %dt11*
  %r5 = getelementptr inbounds %dt11, %dt11* %r4, i32 0, i32 1
  %r3 = load %dt10*, %dt10** %r5
  ; read the tag for a data object
  %r2 = getelementptr inbounds %dt10, %dt10* %r3, i32 0, i32 0
  %r1 = load i32, i32* %r2
  ; branch based on the tag value
  switch i32 %r1, label %b1459 [
      i32 0, label %b1456 ]

b1459:
  %r16 = bitcast %dt10* %r3 to %dt15*
  %r17 = getelementptr inbounds %dt15, %dt15* %r16, i32 0, i32 1
  %r13 = load %dt14*, %dt14** %r17
  %r14 = bitcast %dt14* %r13 to %dt13*
  %r15 = getelementptr inbounds %dt13, %dt13* %r14, i32 0, i32 1
  %r10 = load %dt12*, %dt12** %r15
  %r11 = bitcast %dt14* %r13 to %dt13*
  %r12 = getelementptr inbounds %dt13, %dt13* %r11, i32 0, i32 2
  %r9 = load %dt12*, %dt12** %r12
  %r7 = call i32 @func_b1215(%dt12* %r10)
  %r8 = call i32 @func_b1215(%dt12* %r9)
  %r6 = mul i32 %r7, %r8
  ret i32 %r6

b1456:
  %r21 = bitcast %dt10* %r3 to %dt9*
  %r22 = getelementptr inbounds %dt9, %dt9* %r21, i32 0, i32 1
  %r20 = load %dt8*, %dt8** %r22
  ; read the tag for a data object
  %r19 = getelementptr inbounds %dt8, %dt8* %r20, i32 0, i32 0
  %r18 = load i32, i32* %r19
  ; branch based on the tag value
  switch i32 %r18, label %b1458 [
      i32 0, label %b1632 ]

b1458:
  %r33 = bitcast %dt8* %r20 to %dt16*
  %r34 = getelementptr inbounds %dt16, %dt16* %r33, i32 0, i32 1
  %r30 = load %dt14*, %dt14** %r34
  %r31 = bitcast %dt14* %r30 to %dt13*
  %r32 = getelementptr inbounds %dt13, %dt13* %r31, i32 0, i32 1
  %r27 = load %dt12*, %dt12** %r32
  %r28 = bitcast %dt14* %r30 to %dt13*
  %r29 = getelementptr inbounds %dt13, %dt13* %r28, i32 0, i32 2
  %r26 = load %dt12*, %dt12** %r29
  %r24 = call i32 @func_b1215(%dt12* %r27)
  %r25 = call i32 @func_b1215(%dt12* %r26)
  %r23 = add i32 %r24, %r25
  ret i32 %r23

b1632:
  %r36 = bitcast %dt8* %r20 to %dt7*
  %r37 = getelementptr inbounds %dt7, %dt7* %r36, i32 0, i32 1
  %r35 = load i32, i32* %r37
  ret i32 %r35
}

define internal i32 @func_b1456(%dt10* %r0) {
  br label %b1456

b1456:
  %r4 = bitcast %dt10* %r0 to %dt9*
  %r5 = getelementptr inbounds %dt9, %dt9* %r4, i32 0, i32 1
  %r3 = load %dt8*, %dt8** %r5
  ; read the tag for a data object
  %r2 = getelementptr inbounds %dt8, %dt8* %r3, i32 0, i32 0
  %r1 = load i32, i32* %r2
  ; branch based on the tag value
  switch i32 %r1, label %b1458 [
      i32 0, label %b1632 ]

b1458:
  %r16 = bitcast %dt8* %r3 to %dt16*
  %r17 = getelementptr inbounds %dt16, %dt16* %r16, i32 0, i32 1
  %r13 = load %dt14*, %dt14** %r17
  %r14 = bitcast %dt14* %r13 to %dt13*
  %r15 = getelementptr inbounds %dt13, %dt13* %r14, i32 0, i32 1
  %r10 = load %dt12*, %dt12** %r15
  %r11 = bitcast %dt14* %r13 to %dt13*
  %r12 = getelementptr inbounds %dt13, %dt13* %r11, i32 0, i32 2
  %r9 = load %dt12*, %dt12** %r12
  %r7 = call i32 @func_b1215(%dt12* %r10)
  %r8 = call i32 @func_b1215(%dt12* %r9)
  %r6 = add i32 %r7, %r8
  ret i32 %r6

b1632:
  %r19 = bitcast %dt8* %r3 to %dt7*
  %r20 = getelementptr inbounds %dt7, %dt7* %r19, i32 0, i32 1
  %r18 = load i32, i32* %r20
  ret i32 %r18
}

define internal i32 @func_b1220(%dt20* %r0) {
  br label %b1220

b1220:
  %r4 = bitcast %dt20* %r0 to %dt19*
  %r5 = getelementptr inbounds %dt19, %dt19* %r4, i32 0, i32 1
  %r3 = load %dt18*, %dt18** %r5
  ; read the tag for a data object
  %r2 = getelementptr inbounds %dt18, %dt18* %r3, i32 0, i32 0
  %r1 = load i32, i32* %r2
  ; branch based on the tag value
  switch i32 %r1, label %b1465 [
      i32 0, label %b1633 ]

b1465:
  %r9 = bitcast %dt18* %r3 to %dt25*
  %r10 = getelementptr inbounds %dt25, %dt25* %r9, i32 0, i32 1
  %r8 = load %dt24*, %dt24** %r10
  ; read the tag for a data object
  %r7 = getelementptr inbounds %dt24, %dt24* %r8, i32 0, i32 0
  %r6 = load i32, i32* %r7
  ; branch based on the tag value
  switch i32 %r6, label %b1467 [
      i32 0, label %b1466 ]

b1633:
  %r12 = bitcast %dt18* %r3 to %dt17*
  %r13 = getelementptr inbounds %dt17, %dt17* %r12, i32 0, i32 1
  %r11 = load i32, i32* %r13
  ret i32 %r11

b1467:
  %r24 = bitcast %dt24* %r8 to %dt23*
  %r25 = getelementptr inbounds %dt23, %dt23* %r24, i32 0, i32 1
  %r21 = load %dt22*, %dt22** %r25
  %r22 = bitcast %dt22* %r21 to %dt21*
  %r23 = getelementptr inbounds %dt21, %dt21* %r22, i32 0, i32 1
  %r18 = load %dt20*, %dt20** %r23
  %r19 = bitcast %dt22* %r21 to %dt21*
  %r20 = getelementptr inbounds %dt21, %dt21* %r19, i32 0, i32 2
  %r17 = load %dt20*, %dt20** %r20
  %r15 = call i32 @func_b1220(%dt20* %r18)
  %r16 = call i32 @func_b1220(%dt20* %r17)
  %r14 = mul i32 %r15, %r16
  ret i32 %r14

b1466:
  %r36 = bitcast %dt24* %r8 to %dt26*
  %r37 = getelementptr inbounds %dt26, %dt26* %r36, i32 0, i32 1
  %r33 = load %dt22*, %dt22** %r37
  %r34 = bitcast %dt22* %r33 to %dt21*
  %r35 = getelementptr inbounds %dt21, %dt21* %r34, i32 0, i32 1
  %r30 = load %dt20*, %dt20** %r35
  %r31 = bitcast %dt22* %r33 to %dt21*
  %r32 = getelementptr inbounds %dt21, %dt21* %r31, i32 0, i32 2
  %r29 = load %dt20*, %dt20** %r32
  %r27 = call i32 @func_b1220(%dt20* %r30)
  %r28 = call i32 @func_b1220(%dt20* %r29)
  %r26 = add i32 %r27, %r28
  ret i32 %r26
}

define internal i32 @func_b1465(%dt18* %r0) {
  br label %b1465

b1465:
  %r4 = bitcast %dt18* %r0 to %dt25*
  %r5 = getelementptr inbounds %dt25, %dt25* %r4, i32 0, i32 1
  %r3 = load %dt24*, %dt24** %r5
  ; read the tag for a data object
  %r2 = getelementptr inbounds %dt24, %dt24* %r3, i32 0, i32 0
  %r1 = load i32, i32* %r2
  ; branch based on the tag value
  switch i32 %r1, label %b1467 [
      i32 0, label %b1466 ]

b1467:
  %r16 = bitcast %dt24* %r3 to %dt23*
  %r17 = getelementptr inbounds %dt23, %dt23* %r16, i32 0, i32 1
  %r13 = load %dt22*, %dt22** %r17
  %r14 = bitcast %dt22* %r13 to %dt21*
  %r15 = getelementptr inbounds %dt21, %dt21* %r14, i32 0, i32 1
  %r10 = load %dt20*, %dt20** %r15
  %r11 = bitcast %dt22* %r13 to %dt21*
  %r12 = getelementptr inbounds %dt21, %dt21* %r11, i32 0, i32 2
  %r9 = load %dt20*, %dt20** %r12
  %r7 = call i32 @func_b1220(%dt20* %r10)
  %r8 = call i32 @func_b1220(%dt20* %r9)
  %r6 = mul i32 %r7, %r8
  ret i32 %r6

b1466:
  %r28 = bitcast %dt24* %r3 to %dt26*
  %r29 = getelementptr inbounds %dt26, %dt26* %r28, i32 0, i32 1
  %r25 = load %dt22*, %dt22** %r29
  %r26 = bitcast %dt22* %r25 to %dt21*
  %r27 = getelementptr inbounds %dt21, %dt21* %r26, i32 0, i32 1
  %r22 = load %dt20*, %dt20** %r27
  %r23 = bitcast %dt22* %r25 to %dt21*
  %r24 = getelementptr inbounds %dt21, %dt21* %r23, i32 0, i32 2
  %r21 = load %dt20*, %dt20** %r24
  %r19 = call i32 @func_b1220(%dt20* %r22)
  %r20 = call i32 @func_b1220(%dt20* %r21)
  %r18 = add i32 %r19, %r20
  ret i32 %r18
}

define internal i32 @func_b1394(i32 %r0, i32 %r1, i32 %r2) {
  br label %b1394

b1394:
  %r6 = phi i32 [%r0, %0], [%r8, %b1399]
  %r7 = phi i32 [%r1, %0], [%r7, %b1399]
  %r4 = phi i32 [%r2, %0], [%r4, %b1399]
  %r5 = mul i32 %r6, 100
  %r3 = icmp uge i32 %r4, %r5
  br i1 %r3, label %b1395, label %b1390

b1395:
  %r9 = icmp eq i32 %r6, %r7
  br i1 %r9, label %b1390, label %b1397

b1390:
  %r14 = phi i32 [%r4, %b1394], [%r4, %b1395], [%r4, %b1397]
  %r11 = phi i32 [%r6, %b1394], [%r6, %b1395], [%r6, %b1397]
  %r15 = mul i32 %r11, 10
  %r13 = sub i32 %r14, %r15
  %r12 = call i32 @func_b1387(i32 %r13)
  %r10 = add i32 %r11, %r12
  ret i32 %r10

b1397:
  %r16 = icmp ule i32 %r6, %r7
  br i1 %r16, label %b1399, label %b1390

b1399:
  %r8 = mul i32 %r6, 10
  br label %b1394
}

define internal i32 @func_b1387(i32 %r0) {
  br label %b1387

b1387:
  %r1 = icmp ult i32 %r0, 10
  br i1 %r1, label %b998, label %b1388

b998:
  ret i32 0

b1388:
  %r2 = icmp uge i32 %r0, 100
  br i1 %r2, label %b1389, label %b1390

b1389:
  %r3 = icmp eq i32 1, 10000000
  br i1 %r3, label %b1390, label %b1391

b1390:
  %r8 = phi i32 [%r0, %b1388], [%r0, %b1389], [%r0, %b1391], [%r11, %b1394], [%r11, %b1395], [%r11, %b1397]
  %r5 = phi i32 [1, %b1388], [1, %b1389], [1, %b1391], [%r10, %b1394], [%r10, %b1395], [%r10, %b1397]
  %r9 = mul i32 %r5, 10
  %r7 = sub i32 %r8, %r9
  %r6 = call i32 @func_b1387(i32 %r7)
  %r4 = add i32 %r5, %r6
  ret i32 %r4

b1391:
  %r12 = icmp ule i32 1, 10000000
  br i1 %r12, label %b1393, label %b1390

b1393:
  %r13 = mul i32 1, 10
  br label %b1394

b1394:
  %r10 = phi i32 [%r13, %b1393], [%r17, %b1399]
  %r16 = phi i32 [10000000, %b1393], [%r16, %b1399]
  %r11 = phi i32 [%r0, %b1393], [%r11, %b1399]
  %r15 = mul i32 %r10, 100
  %r14 = icmp uge i32 %r11, %r15
  br i1 %r14, label %b1395, label %b1390

b1395:
  %r18 = icmp eq i32 %r10, %r16
  br i1 %r18, label %b1390, label %b1397

b1397:
  %r19 = icmp ule i32 %r10, %r16
  br i1 %r19, label %b1399, label %b1390

b1399:
  %r17 = mul i32 %r10, 10
  br label %b1394
}

define internal i32 @func_b1251(i32 %r0, i32 %r1, i32 %r2) {
  br label %b1251

b1251:
  %r6 = phi i32 [%r0, %0], [%r8, %b1257]
  %r7 = phi i32 [%r1, %0], [%r7, %b1257]
  %r4 = phi i32 [%r2, %0], [%r4, %b1257]
  %r5 = mul i32 %r6, 100
  %r3 = icmp uge i32 %r4, %r5
  br i1 %r3, label %b1252, label %b1390

b1252:
  %r9 = icmp eq i32 %r6, %r7
  br i1 %r9, label %b1390, label %b1405

b1390:
  %r14 = phi i32 [%r4, %b1251], [%r4, %b1252], [%r4, %b1405]
  %r11 = phi i32 [%r6, %b1251], [%r6, %b1252], [%r6, %b1405]
  %r15 = mul i32 %r11, 10
  %r13 = sub i32 %r14, %r15
  %r12 = call i32 @func_b1387(i32 %r13)
  %r10 = add i32 %r11, %r12
  ret i32 %r10

b1405:
  %r16 = icmp ule i32 %r6, %r7
  br i1 %r16, label %b1257, label %b1390

b1257:
  %r8 = mul i32 %r6, 10
  br label %b1251
}

declare i32 @putchar(i32)

define internal void @func_b1288(i32 %r0) {
  br label %b1288

b1288:
  %r2 = phi i32 [%r0, %0], [%r4, %b1419], [%r3, %b1545]
  %r1 = icmp ult i32 %r2, 10
  br i1 %r1, label %b1289, label %b1426

b1289:
  %r6 = add i32 %r2, 48
  %r5 = call i32 @putchar(i32 %r6)
  ret void

b1426:
  %r7 = icmp ult i32 %r2, 10
  br i1 %r7, label %b1419, label %b1472

b1419:
  %r8 = phi i32 [%r2, %b1426], [%r11, %b1497]
  %r9 = phi i32 [0, %b1426], [%r10, %b1497]
  call void @func_b1288(i32 %r9)
  %r4 = srem i32 %r8, 10
  br label %b1288

b1472:
  %r12 = icmp uge i32 %r2, 100
  br i1 %r12, label %b1496, label %b1497

b1496:
  %r13 = icmp eq i32 1, 10000000
  br i1 %r13, label %b1497, label %b1528

b1497:
  %r11 = phi i32 [%r2, %b1472], [%r2, %b1496], [%r2, %b1528]
  %r14 = phi i32 [1, %b1472], [1, %b1496], [1, %b1528]
  %r17 = mul i32 %r14, 10
  %r16 = sub i32 %r11, %r17
  %r15 = call i32 @func_b1387(i32 %r16)
  %r10 = add i32 %r14, %r15
  br label %b1419

b1528:
  %r18 = icmp ule i32 1, 10000000
  br i1 %r18, label %b1545, label %b1497

b1545:
  %r20 = mul i32 1, 10
  %r19 = call i32 @func_b1394(i32 %r20, i32 10000000, i32 %r2)
  call void @func_b1089(i32 %r19)
  %r3 = srem i32 %r2, 10
  br label %b1288
}

define internal void @func_b1089(i32 %r0) {
  br label %b1089

b1089:
  %r1 = icmp ult i32 %r0, 10
  br i1 %r1, label %b1289, label %b1507

b1289:
  %r4 = phi i32 [%r0, %b1089], [%r5, %b1288]
  %r3 = add i32 %r4, 48
  %r2 = call i32 @putchar(i32 %r3)
  ret void

b1507:
  %r6 = icmp ult i32 %r0, 10
  br i1 %r6, label %b1501, label %b1529

b1501:
  %r9 = phi i32 [0, %b1507], [%r11, %b1547]
  %r8 = phi i32 [%r0, %b1507], [%r10, %b1547]
  call void @func_b1288(i32 %r9)
  %r7 = srem i32 %r8, 10
  br label %b1288

b1529:
  %r12 = icmp uge i32 %r0, 100
  br i1 %r12, label %b1546, label %b1547

b1288:
  %r5 = phi i32 [%r7, %b1501], [%r16, %b1419], [%r15, %b1572], [%r14, %b1545]
  %r13 = icmp ult i32 %r5, 10
  br i1 %r13, label %b1289, label %b1426

b1546:
  %r17 = icmp eq i32 1, 10000000
  br i1 %r17, label %b1547, label %b1564

b1547:
  %r10 = phi i32 [%r0, %b1529], [%r0, %b1546], [%r0, %b1564]
  %r18 = phi i32 [1, %b1529], [1, %b1546], [1, %b1564]
  %r21 = mul i32 %r18, 10
  %r20 = sub i32 %r10, %r21
  %r19 = call i32 @func_b1387(i32 %r20)
  %r11 = add i32 %r18, %r19
  br label %b1501

b1426:
  %r22 = icmp ult i32 %r5, 10
  br i1 %r22, label %b1419, label %b1472

b1564:
  %r23 = icmp ule i32 1, 10000000
  br i1 %r23, label %b1572, label %b1547

b1419:
  %r24 = phi i32 [%r5, %b1426], [%r27, %b1497]
  %r25 = phi i32 [0, %b1426], [%r26, %b1497]
  call void @func_b1288(i32 %r25)
  %r16 = srem i32 %r24, 10
  br label %b1288

b1472:
  %r28 = icmp uge i32 %r5, 100
  br i1 %r28, label %b1496, label %b1497

b1572:
  %r30 = mul i32 1, 10
  %r29 = call i32 @func_b1251(i32 %r30, i32 10000000, i32 %r0)
  call void @func_b1089(i32 %r29)
  %r15 = srem i32 %r0, 10
  br label %b1288

b1496:
  %r31 = icmp eq i32 1, 10000000
  br i1 %r31, label %b1497, label %b1528

b1497:
  %r27 = phi i32 [%r5, %b1472], [%r5, %b1496], [%r5, %b1528]
  %r32 = phi i32 [1, %b1472], [1, %b1496], [1, %b1528]
  %r35 = mul i32 %r32, 10
  %r34 = sub i32 %r27, %r35
  %r33 = call i32 @func_b1387(i32 %r34)
  %r26 = add i32 %r32, %r33
  br label %b1419

b1528:
  %r36 = icmp ule i32 1, 10000000
  br i1 %r36, label %b1545, label %b1497

b1545:
  %r38 = mul i32 1, 10
  %r37 = call i32 @func_b1394(i32 %r38, i32 10000000, i32 %r5)
  call void @func_b1089(i32 %r37)
  %r14 = srem i32 %r5, 10
  br label %b1288
}

declare i8* @alloc(i32)

; layout for k485
%dt40 = type {%dt30, %dt18*}

define internal %dt20* @clos_k485(%dt31* %r0, %dt33* %r1) {
  ; load stored values from closure
  %r10 = bitcast %dt31* %r0 to %dt40*
  %r11 = getelementptr inbounds %dt40, %dt40* %r10, i32 0, i32 1
  %r4 = load %dt18*, %dt18** %r11
  ; body of closure starts here
  ; calculate the number of bytes that we need to allocate
  %r7 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r8 = ptrtoint %dt19* %r7 to i32
  ; allocate memory for the object
  %r9 = call i8* @alloc(i32 %r8)
  %r3 = bitcast i8* %r9 to %dt19*
  ; set the tag
  %r6 = getelementptr inbounds %dt19, %dt19* %r3, i32 0, i32 0
  store i32 0, i32* %r6
  ; initialize other fields
  %r5 = getelementptr inbounds %dt19, %dt19* %r3, i32 0, i32 1
  store %dt18* %r4, %dt18** %r5
  %r2 = bitcast %dt19* %r3 to %dt20*
  ret %dt20* %r2
}

; layout for k500
%dt41 = type {%dt30, i32}

define internal %dt20* @clos_k500(%dt31* %r0, %dt33* %r1) {
  ; load stored values from closure
  %r17 = bitcast %dt31* %r0 to %dt41*
  %r18 = getelementptr inbounds %dt41, %dt41* %r17, i32 0, i32 1
  %r11 = load i32, i32* %r18
  ; body of closure starts here
  br label %b1293

b1293:
  ; calculate the number of bytes that we need to allocate
  %r14 = getelementptr inbounds %dt17, %dt17* null, i32 1
  %r15 = ptrtoint %dt17* %r14 to i32
  ; allocate memory for the object
  %r16 = call i8* @alloc(i32 %r15)
  %r10 = bitcast i8* %r16 to %dt17*
  ; set the tag
  %r13 = getelementptr inbounds %dt17, %dt17* %r10, i32 0, i32 0
  store i32 0, i32* %r13
  ; initialize other fields
  %r12 = getelementptr inbounds %dt17, %dt17* %r10, i32 0, i32 1
  store i32 %r11, i32* %r12
  %r4 = bitcast %dt17* %r10 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r7 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r8 = ptrtoint %dt19* %r7 to i32
  ; allocate memory for the object
  %r9 = call i8* @alloc(i32 %r8)
  %r3 = bitcast i8* %r9 to %dt19*
  ; set the tag
  %r6 = getelementptr inbounds %dt19, %dt19* %r3, i32 0, i32 0
  store i32 0, i32* %r6
  ; initialize other fields
  %r5 = getelementptr inbounds %dt19, %dt19* %r3, i32 0, i32 1
  store %dt18* %r4, %dt18** %r5
  %r2 = bitcast %dt19* %r3 to %dt20*
  ret %dt20* %r2
}

; closure types for [ColonPlusColon_Const_SumColonPlusColonProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgu125] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
%dt42 = type %dt31* (%dt43*, %dt38*)*

%dt43 = type {%dt42}

; data layout for values of type ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226
%dt46 = type {i32}

; closure types for [ColonPlusColon_Sum_ProductColonPlusColonDouble_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgr226] ->> [[[Expr_ConstColonPlusColonSumColonPlusColonProductColonPlusColonDouble$jgs024] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]] ->> [Expr_ConstColonPlusColonSumColonPlusColonProduct$jgm721]]
%dt44 = type %dt31* (%dt45*, %dt46*)*

%dt45 = type {%dt44}

; layout for Inr$jfl236
%dt47 = type {i32, %dt46*}

; layout for k489
%dt48 = type {%dt42, %dt45*}

define internal %dt31* @clos_k489(%dt43* %r0, %dt38* %r1) {
  ; load stored values from closure
  %r21 = bitcast %dt43* %r0 to %dt48*
  %r22 = getelementptr inbounds %dt48, %dt48* %r21, i32 0, i32 1
  %r5 = load %dt45*, %dt45** %r22
  ; body of closure starts here
  br label %b1291

b1291:
  ; read the tag for a data object
  %r3 = getelementptr inbounds %dt38, %dt38* %r1, i32 0, i32 0
  %r2 = load i32, i32* %r3
  ; branch based on the tag value
  switch i32 %r2, label %b1637 [
      i32 0, label %b1636 ]

b1637:
  %r9 = bitcast %dt38* %r1 to %dt47*
  %r10 = getelementptr inbounds %dt47, %dt47* %r9, i32 0, i32 1
  %r6 = load %dt46*, %dt46** %r10
  %r8 = getelementptr inbounds %dt45, %dt45* %r5, i32 0, i32 0
  %r7 = load %dt44, %dt44* %r8
  %r4 = tail call %dt31* %r7(%dt45* %r5, %dt46* %r6)
  ret %dt31* %r4

b1636:
  %r19 = bitcast %dt38* %r1 to %dt37*
  %r20 = getelementptr inbounds %dt37, %dt37* %r19, i32 0, i32 1
  %r13 = load i32, i32* %r20
  ; calculate the number of bytes that we need to allocate
  %r16 = getelementptr inbounds %dt41, %dt41* null, i32 1
  %r17 = ptrtoint %dt41* %r16 to i32
  ; allocate memory for the object
  %r18 = call i8* @alloc(i32 %r17)
  %r12 = bitcast i8* %r18 to %dt41*
  ; set the tag
  %r15 = getelementptr inbounds %dt41, %dt41* %r12, i32 0, i32 0
  store %dt30 @clos_k500, %dt30* %r15
  ; initialize other fields
  %r14 = getelementptr inbounds %dt41, %dt41* %r12, i32 0, i32 1
  store i32 %r13, i32* %r14
  %r11 = bitcast %dt41* %r12 to %dt31*
  ret %dt31* %r11
}

; layout for k109
%dt49 = type {%dt32, %dt43*}

define internal %dt20* @clos_k109(%dt33* %r0, %dt34* %r1) {
  ; load stored values from closure
  %r19 = bitcast %dt33* %r0 to %dt49*
  %r20 = getelementptr inbounds %dt49, %dt49* %r19, i32 0, i32 1
  %r7 = load %dt43*, %dt43** %r20
  ; body of closure starts here
  br label %b167

b167:
  ; calculate the number of bytes that we need to allocate
  %r16 = getelementptr inbounds %dt49, %dt49* null, i32 1
  %r17 = ptrtoint %dt49* %r16 to i32
  ; allocate memory for the object
  %r18 = call i8* @alloc(i32 %r17)
  %r13 = bitcast i8* %r18 to %dt49*
  ; set the tag
  %r15 = getelementptr inbounds %dt49, %dt49* %r13, i32 0, i32 0
  store %dt32 @clos_k109, %dt32* %r15
  ; initialize other fields
  %r14 = getelementptr inbounds %dt49, %dt49* %r13, i32 0, i32 1
  store %dt43* %r7, %dt43** %r14
  %r4 = bitcast %dt49* %r13 to %dt33*
  %r11 = bitcast %dt34* %r1 to %dt39*
  %r12 = getelementptr inbounds %dt39, %dt39* %r11, i32 0, i32 1
  %r8 = load %dt38*, %dt38** %r12
  %r10 = getelementptr inbounds %dt43, %dt43* %r7, i32 0, i32 0
  %r9 = load %dt42, %dt42* %r10
  %r3 = call %dt31* %r9(%dt43* %r7, %dt38* %r8)
  %r6 = getelementptr inbounds %dt31, %dt31* %r3, i32 0, i32 0
  %r5 = load %dt30, %dt30* %r6
  %r2 = tail call %dt20* %r5(%dt31* %r3, %dt33* %r4)
  ret %dt20* %r2
}

; layout for Double$jfb942
%dt50 = type {i32, %dt34*}

; data layout for values of type Double_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgn629
%dt51 = type {i32}

; layout for k384
%dt52 = type {%dt30, %dt51*}

define internal %dt20* @clos_k384(%dt31* %r0, %dt33* %r1) {
  ; load stored values from closure
  %r41 = bitcast %dt31* %r0 to %dt52*
  %r42 = getelementptr inbounds %dt52, %dt52* %r41, i32 0, i32 1
  %r40 = load %dt51*, %dt51** %r42
  ; body of closure starts here
  br label %b903

b903:
  %r38 = bitcast %dt51* %r40 to %dt50*
  %r39 = getelementptr inbounds %dt50, %dt50* %r38, i32 0, i32 1
  %r33 = load %dt34*, %dt34** %r39
  %r37 = getelementptr inbounds %dt33, %dt33* %r1, i32 0, i32 0
  %r36 = load %dt32, %dt32* %r37
  %r27 = call %dt20* %r36(%dt33* %r1, %dt34* %r33)
  %r35 = getelementptr inbounds %dt33, %dt33* %r1, i32 0, i32 0
  %r34 = load %dt32, %dt32* %r35
  %r25 = call %dt20* %r34(%dt33* %r1, %dt34* %r33)
  ; calculate the number of bytes that we need to allocate
  %r30 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r31 = ptrtoint %dt21* %r30 to i32
  ; allocate memory for the object
  %r32 = call i8* @alloc(i32 %r31)
  %r24 = bitcast i8* %r32 to %dt21*
  ; set the tag
  %r29 = getelementptr inbounds %dt21, %dt21* %r24, i32 0, i32 0
  store i32 0, i32* %r29
  ; initialize other fields
  %r28 = getelementptr inbounds %dt21, %dt21* %r24, i32 0, i32 1
  store %dt20* %r27, %dt20** %r28
  %r26 = getelementptr inbounds %dt21, %dt21* %r24, i32 0, i32 2
  store %dt20* %r25, %dt20** %r26
  %r18 = bitcast %dt21* %r24 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r21 = getelementptr inbounds %dt26, %dt26* null, i32 1
  %r22 = ptrtoint %dt26* %r21 to i32
  ; allocate memory for the object
  %r23 = call i8* @alloc(i32 %r22)
  %r17 = bitcast i8* %r23 to %dt26*
  ; set the tag
  %r20 = getelementptr inbounds %dt26, %dt26* %r17, i32 0, i32 0
  store i32 0, i32* %r20
  ; initialize other fields
  %r19 = getelementptr inbounds %dt26, %dt26* %r17, i32 0, i32 1
  store %dt22* %r18, %dt22** %r19
  %r11 = bitcast %dt26* %r17 to %dt24*
  ; calculate the number of bytes that we need to allocate
  %r14 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r15 = ptrtoint %dt25* %r14 to i32
  ; allocate memory for the object
  %r16 = call i8* @alloc(i32 %r15)
  %r10 = bitcast i8* %r16 to %dt25*
  ; set the tag
  %r13 = getelementptr inbounds %dt25, %dt25* %r10, i32 0, i32 0
  store i32 1, i32* %r13
  ; initialize other fields
  %r12 = getelementptr inbounds %dt25, %dt25* %r10, i32 0, i32 1
  store %dt24* %r11, %dt24** %r12
  %r4 = bitcast %dt25* %r10 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r7 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r8 = ptrtoint %dt19* %r7 to i32
  ; allocate memory for the object
  %r9 = call i8* @alloc(i32 %r8)
  %r3 = bitcast i8* %r9 to %dt19*
  ; set the tag
  %r6 = getelementptr inbounds %dt19, %dt19* %r3, i32 0, i32 0
  store i32 0, i32* %r6
  ; initialize other fields
  %r5 = getelementptr inbounds %dt19, %dt19* %r3, i32 0, i32 1
  store %dt18* %r4, %dt18** %r5
  %r2 = bitcast %dt19* %r3 to %dt20*
  ret %dt20* %r2
}

; layout for Inr$jfh539
%dt53 = type {i32, %dt29*}

; data layout for values of type Product_ExprLParenConstColonPlusColonSumColonPlusColonProductColonPlusColonDoubleRParen$jgo527
%dt54 = type {i32}

; layout for Inl$jfg337
%dt55 = type {i32, %dt54*}

; layout for k488
%dt56 = type {%dt44, %dt28*}

define internal %dt31* @clos_k488(%dt45* %r0, %dt46* %r1) {
  ; load stored values from closure
  %r22 = bitcast %dt45* %r0 to %dt56*
  %r23 = getelementptr inbounds %dt56, %dt56* %r22, i32 0, i32 1
  %r5 = load %dt28*, %dt28** %r23
  ; body of closure starts here
  br label %b1294

b1294:
  ; read the tag for a data object
  %r3 = getelementptr inbounds %dt46, %dt46* %r1, i32 0, i32 0
  %r2 = load i32, i32* %r3
  ; branch based on the tag value
  switch i32 %r2, label %b1638 [
      i32 0, label %b1295 ]

b1638:
  %r9 = bitcast %dt46* %r1 to %dt53*
  %r10 = getelementptr inbounds %dt53, %dt53* %r9, i32 0, i32 1
  %r6 = load %dt29*, %dt29** %r10
  %r8 = getelementptr inbounds %dt28, %dt28* %r5, i32 0, i32 0
  %r7 = load %dt27, %dt27* %r8
  %r4 = tail call %dt31* %r7(%dt28* %r5, %dt29* %r6)
  ret %dt31* %r4

b1295:
  %r20 = bitcast %dt46* %r1 to %dt55*
  %r21 = getelementptr inbounds %dt55, %dt55* %r20, i32 0, i32 1
  %r19 = load %dt54*, %dt54** %r21
  %r13 = call %dt18* @func_b1306(%dt54* %r19)
  ; calculate the number of bytes that we need to allocate
  %r16 = getelementptr inbounds %dt40, %dt40* null, i32 1
  %r17 = ptrtoint %dt40* %r16 to i32
  ; allocate memory for the object
  %r18 = call i8* @alloc(i32 %r17)
  %r12 = bitcast i8* %r18 to %dt40*
  ; set the tag
  %r15 = getelementptr inbounds %dt40, %dt40* %r12, i32 0, i32 0
  store %dt30 @clos_k485, %dt30* %r15
  ; initialize other fields
  %r14 = getelementptr inbounds %dt40, %dt40* %r12, i32 0, i32 1
  store %dt18* %r13, %dt18** %r14
  %r11 = bitcast %dt40* %r12 to %dt31*
  ret %dt31* %r11
}

define internal %dt18* @func_b1306(%dt54* %r0) {
  br label %b1306

b1306:
  %r3 = call %dt24* @func_b1307(%dt54* %r0)
  ; calculate the number of bytes that we need to allocate
  %r6 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r7 = ptrtoint %dt25* %r6 to i32
  ; allocate memory for the object
  %r8 = call i8* @alloc(i32 %r7)
  %r2 = bitcast i8* %r8 to %dt25*
  ; set the tag
  %r5 = getelementptr inbounds %dt25, %dt25* %r2, i32 0, i32 0
  store i32 1, i32* %r5
  ; initialize other fields
  %r4 = getelementptr inbounds %dt25, %dt25* %r2, i32 0, i32 1
  store %dt24* %r3, %dt24** %r4
  %r1 = bitcast %dt25* %r2 to %dt18*
  ret %dt18* %r1
}

; layout for Product$jfc738
%dt57 = type {i32, %dt34*, %dt34*}

define internal %dt24* @func_b1307(%dt54* %r0) {
  br label %b1307

b1307:
  %r22 = bitcast %dt54* %r0 to %dt57*
  %r23 = getelementptr inbounds %dt57, %dt57* %r22, i32 0, i32 1
  %r19 = load %dt34*, %dt34** %r23
  %r20 = bitcast %dt54* %r0 to %dt57*
  %r21 = getelementptr inbounds %dt57, %dt57* %r20, i32 0, i32 2
  %r18 = load %dt34*, %dt34** %r21
  %r12 = call %dt20* @func_b908(%dt34* %r19)
  %r10 = call %dt20* @func_b908(%dt34* %r18)
  ; calculate the number of bytes that we need to allocate
  %r15 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r16 = ptrtoint %dt21* %r15 to i32
  ; allocate memory for the object
  %r17 = call i8* @alloc(i32 %r16)
  %r9 = bitcast i8* %r17 to %dt21*
  ; set the tag
  %r14 = getelementptr inbounds %dt21, %dt21* %r9, i32 0, i32 0
  store i32 0, i32* %r14
  ; initialize other fields
  %r13 = getelementptr inbounds %dt21, %dt21* %r9, i32 0, i32 1
  store %dt20* %r12, %dt20** %r13
  %r11 = getelementptr inbounds %dt21, %dt21* %r9, i32 0, i32 2
  store %dt20* %r10, %dt20** %r11
  %r3 = bitcast %dt21* %r9 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r6 = getelementptr inbounds %dt26, %dt26* null, i32 1
  %r7 = ptrtoint %dt26* %r6 to i32
  ; allocate memory for the object
  %r8 = call i8* @alloc(i32 %r7)
  %r2 = bitcast i8* %r8 to %dt26*
  ; set the tag
  %r5 = getelementptr inbounds %dt26, %dt26* %r2, i32 0, i32 0
  store i32 0, i32* %r5
  ; initialize other fields
  %r4 = getelementptr inbounds %dt26, %dt26* %r2, i32 0, i32 1
  store %dt22* %r3, %dt22** %r4
  %r1 = bitcast %dt26* %r2 to %dt24*
  ret %dt24* %r1
}

; layout for Inr$jfe841
%dt58 = type {i32, %dt51*}

; layout for Inl$jfd640
%dt59 = type {i32, %dt54*}

define internal %dt31* @clos_k487(%dt28* %r0, %dt29* %r1) {
  ; body of closure starts here
  br label %b1182

b1182:
  ; read the tag for a data object
  %r3 = getelementptr inbounds %dt29, %dt29* %r1, i32 0, i32 0
  %r2 = load i32, i32* %r3
  ; branch based on the tag value
  switch i32 %r2, label %b1639 [
      i32 0, label %b1311 ]

b1639:
  %r12 = bitcast %dt29* %r1 to %dt58*
  %r13 = getelementptr inbounds %dt58, %dt58* %r12, i32 0, i32 1
  %r6 = load %dt51*, %dt51** %r13
  ; calculate the number of bytes that we need to allocate
  %r9 = getelementptr inbounds %dt52, %dt52* null, i32 1
  %r10 = ptrtoint %dt52* %r9 to i32
  ; allocate memory for the object
  %r11 = call i8* @alloc(i32 %r10)
  %r5 = bitcast i8* %r11 to %dt52*
  ; set the tag
  %r8 = getelementptr inbounds %dt52, %dt52* %r5, i32 0, i32 0
  store %dt30 @clos_k384, %dt30* %r8
  ; initialize other fields
  %r7 = getelementptr inbounds %dt52, %dt52* %r5, i32 0, i32 1
  store %dt51* %r6, %dt51** %r7
  %r4 = bitcast %dt52* %r5 to %dt31*
  ret %dt31* %r4

b1311:
  %r23 = bitcast %dt29* %r1 to %dt59*
  %r24 = getelementptr inbounds %dt59, %dt59* %r23, i32 0, i32 1
  %r22 = load %dt54*, %dt54** %r24
  %r16 = call %dt18* @func_b1318(%dt54* %r22)
  ; calculate the number of bytes that we need to allocate
  %r19 = getelementptr inbounds %dt40, %dt40* null, i32 1
  %r20 = ptrtoint %dt40* %r19 to i32
  ; allocate memory for the object
  %r21 = call i8* @alloc(i32 %r20)
  %r15 = bitcast i8* %r21 to %dt40*
  ; set the tag
  %r18 = getelementptr inbounds %dt40, %dt40* %r15, i32 0, i32 0
  store %dt30 @clos_k485, %dt30* %r18
  ; initialize other fields
  %r17 = getelementptr inbounds %dt40, %dt40* %r15, i32 0, i32 1
  store %dt18* %r16, %dt18** %r17
  %r14 = bitcast %dt40* %r15 to %dt31*
  ret %dt31* %r14
}

define internal %dt18* @func_b1318(%dt54* %r0) {
  br label %b1318

b1318:
  %r3 = call %dt24* @func_b1319(%dt54* %r0)
  ; calculate the number of bytes that we need to allocate
  %r6 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r7 = ptrtoint %dt25* %r6 to i32
  ; allocate memory for the object
  %r8 = call i8* @alloc(i32 %r7)
  %r2 = bitcast i8* %r8 to %dt25*
  ; set the tag
  %r5 = getelementptr inbounds %dt25, %dt25* %r2, i32 0, i32 0
  store i32 1, i32* %r5
  ; initialize other fields
  %r4 = getelementptr inbounds %dt25, %dt25* %r2, i32 0, i32 1
  store %dt24* %r3, %dt24** %r4
  %r1 = bitcast %dt25* %r2 to %dt18*
  ret %dt18* %r1
}

define internal %dt24* @func_b1319(%dt54* %r0) {
  br label %b1319

b1319:
  %r22 = bitcast %dt54* %r0 to %dt57*
  %r23 = getelementptr inbounds %dt57, %dt57* %r22, i32 0, i32 1
  %r19 = load %dt34*, %dt34** %r23
  %r20 = bitcast %dt54* %r0 to %dt57*
  %r21 = getelementptr inbounds %dt57, %dt57* %r20, i32 0, i32 2
  %r18 = load %dt34*, %dt34** %r21
  %r12 = call %dt20* @func_b908(%dt34* %r19)
  %r10 = call %dt20* @func_b908(%dt34* %r18)
  ; calculate the number of bytes that we need to allocate
  %r15 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r16 = ptrtoint %dt21* %r15 to i32
  ; allocate memory for the object
  %r17 = call i8* @alloc(i32 %r16)
  %r9 = bitcast i8* %r17 to %dt21*
  ; set the tag
  %r14 = getelementptr inbounds %dt21, %dt21* %r9, i32 0, i32 0
  store i32 0, i32* %r14
  ; initialize other fields
  %r13 = getelementptr inbounds %dt21, %dt21* %r9, i32 0, i32 1
  store %dt20* %r12, %dt20** %r13
  %r11 = getelementptr inbounds %dt21, %dt21* %r9, i32 0, i32 2
  store %dt20* %r10, %dt20** %r11
  %r3 = bitcast %dt21* %r9 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r6 = getelementptr inbounds %dt23, %dt23* null, i32 1
  %r7 = ptrtoint %dt23* %r6 to i32
  ; allocate memory for the object
  %r8 = call i8* @alloc(i32 %r7)
  %r2 = bitcast i8* %r8 to %dt23*
  ; set the tag
  %r5 = getelementptr inbounds %dt23, %dt23* %r2, i32 0, i32 0
  store i32 1, i32* %r5
  ; initialize other fields
  %r4 = getelementptr inbounds %dt23, %dt23* %r2, i32 0, i32 1
  store %dt22* %r3, %dt22** %r4
  %r1 = bitcast %dt23* %r2 to %dt24*
  ret %dt24* %r1
}

define internal %dt20* @func_b908(%dt34* %r0) {
  br label %b908

b908:
  %r1 = call %dt43* @func_b1179()
  br label %b167

b167:
  ; calculate the number of bytes that we need to allocate
  %r15 = getelementptr inbounds %dt49, %dt49* null, i32 1
  %r16 = ptrtoint %dt49* %r15 to i32
  ; allocate memory for the object
  %r17 = call i8* @alloc(i32 %r16)
  %r12 = bitcast i8* %r17 to %dt49*
  ; set the tag
  %r14 = getelementptr inbounds %dt49, %dt49* %r12, i32 0, i32 0
  store %dt32 @clos_k109, %dt32* %r14
  ; initialize other fields
  %r13 = getelementptr inbounds %dt49, %dt49* %r12, i32 0, i32 1
  store %dt43* %r1, %dt43** %r13
  %r4 = bitcast %dt49* %r12 to %dt33*
  %r10 = bitcast %dt34* %r0 to %dt39*
  %r11 = getelementptr inbounds %dt39, %dt39* %r10, i32 0, i32 1
  %r7 = load %dt38*, %dt38** %r11
  %r9 = getelementptr inbounds %dt43, %dt43* %r1, i32 0, i32 0
  %r8 = load %dt42, %dt42* %r9
  %r3 = call %dt31* %r8(%dt43* %r1, %dt38* %r7)
  %r6 = getelementptr inbounds %dt31, %dt31* %r3, i32 0, i32 0
  %r5 = load %dt30, %dt30* %r6
  %r2 = tail call %dt20* %r5(%dt31* %r3, %dt33* %r4)
  ret %dt20* %r2
}

define internal %dt43* @func_b1179() {
  br label %b1179

b1179:
  %r2 = call %dt45* @func_b1180()
  ; calculate the number of bytes that we need to allocate
  %r5 = getelementptr inbounds %dt48, %dt48* null, i32 1
  %r6 = ptrtoint %dt48* %r5 to i32
  ; allocate memory for the object
  %r7 = call i8* @alloc(i32 %r6)
  %r1 = bitcast i8* %r7 to %dt48*
  ; set the tag
  %r4 = getelementptr inbounds %dt48, %dt48* %r1, i32 0, i32 0
  store %dt42 @clos_k489, %dt42* %r4
  ; initialize other fields
  %r3 = getelementptr inbounds %dt48, %dt48* %r1, i32 0, i32 1
  store %dt45* %r2, %dt45** %r3
  %r0 = bitcast %dt48* %r1 to %dt43*
  ret %dt43* %r0
}

define internal %dt45* @func_b1180() {
  br label %b1180

b1180:
  %r2 = call %dt28* @func_b1181()
  ; calculate the number of bytes that we need to allocate
  %r5 = getelementptr inbounds %dt56, %dt56* null, i32 1
  %r6 = ptrtoint %dt56* %r5 to i32
  ; allocate memory for the object
  %r7 = call i8* @alloc(i32 %r6)
  %r1 = bitcast i8* %r7 to %dt56*
  ; set the tag
  %r4 = getelementptr inbounds %dt56, %dt56* %r1, i32 0, i32 0
  store %dt44 @clos_k488, %dt44* %r4
  ; initialize other fields
  %r3 = getelementptr inbounds %dt56, %dt56* %r1, i32 0, i32 1
  store %dt28* %r2, %dt28** %r3
  %r0 = bitcast %dt56* %r1 to %dt45*
  ret %dt45* %r0
}

define internal %dt28* @func_b1181() {
  br label %b1181

b1181:
  ret %dt28* @val.69
}

; layout for k512
%dt60 = type {%dt32, %dt28*}

define internal %dt20* @clos_k512(%dt33* %r0, %dt34* %r1) {
  ; load stored values from closure
  %r99 = bitcast %dt33* %r0 to %dt60*
  %r100 = getelementptr inbounds %dt60, %dt60* %r99, i32 0, i32 1
  %r9 = load %dt28*, %dt28** %r100
  ; body of closure starts here
  br label %b1531

b1531:
  ; calculate the number of bytes that we need to allocate
  %r12 = getelementptr inbounds %dt60, %dt60* null, i32 1
  %r13 = ptrtoint %dt60* %r12 to i32
  ; allocate memory for the object
  %r14 = call i8* @alloc(i32 %r13)
  %r8 = bitcast i8* %r14 to %dt60*
  ; set the tag
  %r11 = getelementptr inbounds %dt60, %dt60* %r8, i32 0, i32 0
  store %dt32 @clos_k512, %dt32* %r11
  ; initialize other fields
  %r10 = getelementptr inbounds %dt60, %dt60* %r8, i32 0, i32 1
  store %dt28* %r9, %dt28** %r10
  %r7 = bitcast %dt60* %r8 to %dt33*
  %r5 = bitcast %dt34* %r1 to %dt39*
  %r6 = getelementptr inbounds %dt39, %dt39* %r5, i32 0, i32 1
  %r4 = load %dt38*, %dt38** %r6
  ; read the tag for a data object
  %r3 = getelementptr inbounds %dt38, %dt38* %r4, i32 0, i32 0
  %r2 = load i32, i32* %r3
  ; branch based on the tag value
  switch i32 %r2, label %b1548 [
      i32 0, label %b1640 ]

b1548:
  %r16 = bitcast %dt38* %r4 to %dt47*
  %r17 = getelementptr inbounds %dt47, %dt47* %r16, i32 0, i32 1
  %r15 = load %dt46*, %dt46** %r17
  br label %b1445

b1640:
  %r33 = bitcast %dt38* %r4 to %dt37*
  %r34 = getelementptr inbounds %dt37, %dt37* %r33, i32 0, i32 1
  %r27 = load i32, i32* %r34
  ; calculate the number of bytes that we need to allocate
  %r30 = getelementptr inbounds %dt17, %dt17* null, i32 1
  %r31 = ptrtoint %dt17* %r30 to i32
  ; allocate memory for the object
  %r32 = call i8* @alloc(i32 %r31)
  %r26 = bitcast i8* %r32 to %dt17*
  ; set the tag
  %r29 = getelementptr inbounds %dt17, %dt17* %r26, i32 0, i32 0
  store i32 0, i32* %r29
  ; initialize other fields
  %r28 = getelementptr inbounds %dt17, %dt17* %r26, i32 0, i32 1
  store i32 %r27, i32* %r28
  %r20 = bitcast %dt17* %r26 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r23 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r24 = ptrtoint %dt19* %r23 to i32
  ; allocate memory for the object
  %r25 = call i8* @alloc(i32 %r24)
  %r19 = bitcast i8* %r25 to %dt19*
  ; set the tag
  %r22 = getelementptr inbounds %dt19, %dt19* %r19, i32 0, i32 0
  store i32 0, i32* %r22
  ; initialize other fields
  %r21 = getelementptr inbounds %dt19, %dt19* %r19, i32 0, i32 1
  store %dt18* %r20, %dt18** %r21
  %r18 = bitcast %dt19* %r19 to %dt20*
  ret %dt20* %r18

b1445:
  ; read the tag for a data object
  %r36 = getelementptr inbounds %dt46, %dt46* %r15, i32 0, i32 0
  %r35 = load i32, i32* %r36
  ; branch based on the tag value
  switch i32 %r35, label %b1641 [
      i32 0, label %b1473 ]

b1641:
  %r44 = bitcast %dt46* %r15 to %dt53*
  %r45 = getelementptr inbounds %dt53, %dt53* %r44, i32 0, i32 1
  %r41 = load %dt29*, %dt29** %r45
  %r43 = getelementptr inbounds %dt28, %dt28* %r9, i32 0, i32 0
  %r42 = load %dt27, %dt27* %r43
  %r38 = call %dt31* %r42(%dt28* %r9, %dt29* %r41)
  %r40 = getelementptr inbounds %dt31, %dt31* %r38, i32 0, i32 0
  %r39 = load %dt30, %dt30* %r40
  %r37 = tail call %dt20* %r39(%dt31* %r38, %dt33* %r7)
  ret %dt20* %r37

b1473:
  %r97 = bitcast %dt46* %r15 to %dt55*
  %r98 = getelementptr inbounds %dt55, %dt55* %r97, i32 0, i32 1
  %r94 = load %dt54*, %dt54** %r98
  %r95 = bitcast %dt54* %r94 to %dt57*
  %r96 = getelementptr inbounds %dt57, %dt57* %r95, i32 0, i32 1
  %r85 = load %dt34*, %dt34** %r96
  %r92 = bitcast %dt54* %r94 to %dt57*
  %r93 = getelementptr inbounds %dt57, %dt57* %r92, i32 0, i32 2
  %r81 = load %dt34*, %dt34** %r93
  ; calculate the number of bytes that we need to allocate
  %r89 = getelementptr inbounds %dt60, %dt60* null, i32 1
  %r90 = ptrtoint %dt60* %r89 to i32
  ; allocate memory for the object
  %r91 = call i8* @alloc(i32 %r90)
  %r86 = bitcast i8* %r91 to %dt60*
  ; set the tag
  %r88 = getelementptr inbounds %dt60, %dt60* %r86, i32 0, i32 0
  store %dt32 @clos_k512, %dt32* %r88
  ; initialize other fields
  %r87 = getelementptr inbounds %dt60, %dt60* %r86, i32 0, i32 1
  store %dt28* @val.69, %dt28** %r87
  %r78 = bitcast %dt60* %r86 to %dt33*
  %r83 = bitcast %dt34* %r85 to %dt39*
  %r84 = getelementptr inbounds %dt39, %dt39* %r83, i32 0, i32 1
  %r82 = load %dt38*, %dt38** %r84
  %r71 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r82, %dt33* %r78)
  %r79 = bitcast %dt34* %r81 to %dt39*
  %r80 = getelementptr inbounds %dt39, %dt39* %r79, i32 0, i32 1
  %r77 = load %dt38*, %dt38** %r80
  %r69 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r77, %dt33* %r78)
  ; calculate the number of bytes that we need to allocate
  %r74 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r75 = ptrtoint %dt21* %r74 to i32
  ; allocate memory for the object
  %r76 = call i8* @alloc(i32 %r75)
  %r68 = bitcast i8* %r76 to %dt21*
  ; set the tag
  %r73 = getelementptr inbounds %dt21, %dt21* %r68, i32 0, i32 0
  store i32 0, i32* %r73
  ; initialize other fields
  %r72 = getelementptr inbounds %dt21, %dt21* %r68, i32 0, i32 1
  store %dt20* %r71, %dt20** %r72
  %r70 = getelementptr inbounds %dt21, %dt21* %r68, i32 0, i32 2
  store %dt20* %r69, %dt20** %r70
  %r62 = bitcast %dt21* %r68 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r65 = getelementptr inbounds %dt26, %dt26* null, i32 1
  %r66 = ptrtoint %dt26* %r65 to i32
  ; allocate memory for the object
  %r67 = call i8* @alloc(i32 %r66)
  %r61 = bitcast i8* %r67 to %dt26*
  ; set the tag
  %r64 = getelementptr inbounds %dt26, %dt26* %r61, i32 0, i32 0
  store i32 0, i32* %r64
  ; initialize other fields
  %r63 = getelementptr inbounds %dt26, %dt26* %r61, i32 0, i32 1
  store %dt22* %r62, %dt22** %r63
  %r55 = bitcast %dt26* %r61 to %dt24*
  ; calculate the number of bytes that we need to allocate
  %r58 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r59 = ptrtoint %dt25* %r58 to i32
  ; allocate memory for the object
  %r60 = call i8* @alloc(i32 %r59)
  %r54 = bitcast i8* %r60 to %dt25*
  ; set the tag
  %r57 = getelementptr inbounds %dt25, %dt25* %r54, i32 0, i32 0
  store i32 1, i32* %r57
  ; initialize other fields
  %r56 = getelementptr inbounds %dt25, %dt25* %r54, i32 0, i32 1
  store %dt24* %r55, %dt24** %r56
  %r48 = bitcast %dt25* %r54 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r51 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r52 = ptrtoint %dt19* %r51 to i32
  ; allocate memory for the object
  %r53 = call i8* @alloc(i32 %r52)
  %r47 = bitcast i8* %r53 to %dt19*
  ; set the tag
  %r50 = getelementptr inbounds %dt19, %dt19* %r47, i32 0, i32 0
  store i32 0, i32* %r50
  ; initialize other fields
  %r49 = getelementptr inbounds %dt19, %dt19* %r47, i32 0, i32 1
  store %dt18* %r48, %dt18** %r49
  %r46 = bitcast %dt19* %r47 to %dt20*
  ret %dt20* %r46
}

define internal %dt20* @func_b1522(%dt28* %r0, %dt38* %r1, %dt33* %r2) {
  br label %b1522

b1522:
  ; read the tag for a data object
  %r4 = getelementptr inbounds %dt38, %dt38* %r1, i32 0, i32 0
  %r3 = load i32, i32* %r4
  ; branch based on the tag value
  switch i32 %r3, label %b1548 [
      i32 0, label %b1640 ]

b1548:
  %r6 = bitcast %dt38* %r1 to %dt47*
  %r7 = getelementptr inbounds %dt47, %dt47* %r6, i32 0, i32 1
  %r5 = load %dt46*, %dt46** %r7
  br label %b1445

b1640:
  %r23 = bitcast %dt38* %r1 to %dt37*
  %r24 = getelementptr inbounds %dt37, %dt37* %r23, i32 0, i32 1
  %r17 = load i32, i32* %r24
  ; calculate the number of bytes that we need to allocate
  %r20 = getelementptr inbounds %dt17, %dt17* null, i32 1
  %r21 = ptrtoint %dt17* %r20 to i32
  ; allocate memory for the object
  %r22 = call i8* @alloc(i32 %r21)
  %r16 = bitcast i8* %r22 to %dt17*
  ; set the tag
  %r19 = getelementptr inbounds %dt17, %dt17* %r16, i32 0, i32 0
  store i32 0, i32* %r19
  ; initialize other fields
  %r18 = getelementptr inbounds %dt17, %dt17* %r16, i32 0, i32 1
  store i32 %r17, i32* %r18
  %r10 = bitcast %dt17* %r16 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r13 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r14 = ptrtoint %dt19* %r13 to i32
  ; allocate memory for the object
  %r15 = call i8* @alloc(i32 %r14)
  %r9 = bitcast i8* %r15 to %dt19*
  ; set the tag
  %r12 = getelementptr inbounds %dt19, %dt19* %r9, i32 0, i32 0
  store i32 0, i32* %r12
  ; initialize other fields
  %r11 = getelementptr inbounds %dt19, %dt19* %r9, i32 0, i32 1
  store %dt18* %r10, %dt18** %r11
  %r8 = bitcast %dt19* %r9 to %dt20*
  ret %dt20* %r8

b1445:
  ; read the tag for a data object
  %r26 = getelementptr inbounds %dt46, %dt46* %r5, i32 0, i32 0
  %r25 = load i32, i32* %r26
  ; branch based on the tag value
  switch i32 %r25, label %b1641 [
      i32 0, label %b1473 ]

b1641:
  %r34 = bitcast %dt46* %r5 to %dt53*
  %r35 = getelementptr inbounds %dt53, %dt53* %r34, i32 0, i32 1
  %r31 = load %dt29*, %dt29** %r35
  %r33 = getelementptr inbounds %dt28, %dt28* %r0, i32 0, i32 0
  %r32 = load %dt27, %dt27* %r33
  %r28 = call %dt31* %r32(%dt28* %r0, %dt29* %r31)
  %r30 = getelementptr inbounds %dt31, %dt31* %r28, i32 0, i32 0
  %r29 = load %dt30, %dt30* %r30
  %r27 = tail call %dt20* %r29(%dt31* %r28, %dt33* %r2)
  ret %dt20* %r27

b1473:
  %r87 = bitcast %dt46* %r5 to %dt55*
  %r88 = getelementptr inbounds %dt55, %dt55* %r87, i32 0, i32 1
  %r84 = load %dt54*, %dt54** %r88
  %r85 = bitcast %dt54* %r84 to %dt57*
  %r86 = getelementptr inbounds %dt57, %dt57* %r85, i32 0, i32 1
  %r75 = load %dt34*, %dt34** %r86
  %r82 = bitcast %dt54* %r84 to %dt57*
  %r83 = getelementptr inbounds %dt57, %dt57* %r82, i32 0, i32 2
  %r71 = load %dt34*, %dt34** %r83
  ; calculate the number of bytes that we need to allocate
  %r79 = getelementptr inbounds %dt60, %dt60* null, i32 1
  %r80 = ptrtoint %dt60* %r79 to i32
  ; allocate memory for the object
  %r81 = call i8* @alloc(i32 %r80)
  %r76 = bitcast i8* %r81 to %dt60*
  ; set the tag
  %r78 = getelementptr inbounds %dt60, %dt60* %r76, i32 0, i32 0
  store %dt32 @clos_k512, %dt32* %r78
  ; initialize other fields
  %r77 = getelementptr inbounds %dt60, %dt60* %r76, i32 0, i32 1
  store %dt28* @val.69, %dt28** %r77
  %r68 = bitcast %dt60* %r76 to %dt33*
  %r73 = bitcast %dt34* %r75 to %dt39*
  %r74 = getelementptr inbounds %dt39, %dt39* %r73, i32 0, i32 1
  %r72 = load %dt38*, %dt38** %r74
  %r61 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r72, %dt33* %r68)
  %r69 = bitcast %dt34* %r71 to %dt39*
  %r70 = getelementptr inbounds %dt39, %dt39* %r69, i32 0, i32 1
  %r67 = load %dt38*, %dt38** %r70
  %r59 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r67, %dt33* %r68)
  ; calculate the number of bytes that we need to allocate
  %r64 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r65 = ptrtoint %dt21* %r64 to i32
  ; allocate memory for the object
  %r66 = call i8* @alloc(i32 %r65)
  %r58 = bitcast i8* %r66 to %dt21*
  ; set the tag
  %r63 = getelementptr inbounds %dt21, %dt21* %r58, i32 0, i32 0
  store i32 0, i32* %r63
  ; initialize other fields
  %r62 = getelementptr inbounds %dt21, %dt21* %r58, i32 0, i32 1
  store %dt20* %r61, %dt20** %r62
  %r60 = getelementptr inbounds %dt21, %dt21* %r58, i32 0, i32 2
  store %dt20* %r59, %dt20** %r60
  %r52 = bitcast %dt21* %r58 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r55 = getelementptr inbounds %dt26, %dt26* null, i32 1
  %r56 = ptrtoint %dt26* %r55 to i32
  ; allocate memory for the object
  %r57 = call i8* @alloc(i32 %r56)
  %r51 = bitcast i8* %r57 to %dt26*
  ; set the tag
  %r54 = getelementptr inbounds %dt26, %dt26* %r51, i32 0, i32 0
  store i32 0, i32* %r54
  ; initialize other fields
  %r53 = getelementptr inbounds %dt26, %dt26* %r51, i32 0, i32 1
  store %dt22* %r52, %dt22** %r53
  %r45 = bitcast %dt26* %r51 to %dt24*
  ; calculate the number of bytes that we need to allocate
  %r48 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r49 = ptrtoint %dt25* %r48 to i32
  ; allocate memory for the object
  %r50 = call i8* @alloc(i32 %r49)
  %r44 = bitcast i8* %r50 to %dt25*
  ; set the tag
  %r47 = getelementptr inbounds %dt25, %dt25* %r44, i32 0, i32 0
  store i32 1, i32* %r47
  ; initialize other fields
  %r46 = getelementptr inbounds %dt25, %dt25* %r44, i32 0, i32 1
  store %dt24* %r45, %dt24** %r46
  %r38 = bitcast %dt25* %r44 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r41 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r42 = ptrtoint %dt19* %r41 to i32
  ; allocate memory for the object
  %r43 = call i8* @alloc(i32 %r42)
  %r37 = bitcast i8* %r43 to %dt19*
  ; set the tag
  %r40 = getelementptr inbounds %dt19, %dt19* %r37, i32 0, i32 0
  store i32 0, i32* %r40
  ; initialize other fields
  %r39 = getelementptr inbounds %dt19, %dt19* %r37, i32 0, i32 1
  store %dt18* %r38, %dt18** %r39
  %r36 = bitcast %dt19* %r37 to %dt20*
  ret %dt20* %r36
}

define internal %dt20* @clos_k513(%dt33* %r0, %dt34* %r1) {
  ; body of closure starts here
  br label %b1534

b1534:
  %r5 = bitcast %dt34* %r1 to %dt39*
  %r6 = getelementptr inbounds %dt39, %dt39* %r5, i32 0, i32 1
  %r4 = load %dt38*, %dt38** %r6
  ; read the tag for a data object
  %r3 = getelementptr inbounds %dt38, %dt38* %r4, i32 0, i32 0
  %r2 = load i32, i32* %r3
  ; branch based on the tag value
  switch i32 %r2, label %b1553 [
      i32 0, label %b1640 ]

b1553:
  %r8 = bitcast %dt38* %r4 to %dt47*
  %r9 = getelementptr inbounds %dt47, %dt47* %r8, i32 0, i32 1
  %r7 = load %dt46*, %dt46** %r9
  br label %b1445

b1640:
  %r25 = bitcast %dt38* %r4 to %dt37*
  %r26 = getelementptr inbounds %dt37, %dt37* %r25, i32 0, i32 1
  %r19 = load i32, i32* %r26
  ; calculate the number of bytes that we need to allocate
  %r22 = getelementptr inbounds %dt17, %dt17* null, i32 1
  %r23 = ptrtoint %dt17* %r22 to i32
  ; allocate memory for the object
  %r24 = call i8* @alloc(i32 %r23)
  %r18 = bitcast i8* %r24 to %dt17*
  ; set the tag
  %r21 = getelementptr inbounds %dt17, %dt17* %r18, i32 0, i32 0
  store i32 0, i32* %r21
  ; initialize other fields
  %r20 = getelementptr inbounds %dt17, %dt17* %r18, i32 0, i32 1
  store i32 %r19, i32* %r20
  %r12 = bitcast %dt17* %r18 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r15 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r16 = ptrtoint %dt19* %r15 to i32
  ; allocate memory for the object
  %r17 = call i8* @alloc(i32 %r16)
  %r11 = bitcast i8* %r17 to %dt19*
  ; set the tag
  %r14 = getelementptr inbounds %dt19, %dt19* %r11, i32 0, i32 0
  store i32 0, i32* %r14
  ; initialize other fields
  %r13 = getelementptr inbounds %dt19, %dt19* %r11, i32 0, i32 1
  store %dt18* %r12, %dt18** %r13
  %r10 = bitcast %dt19* %r11 to %dt20*
  ret %dt20* %r10

b1445:
  ; read the tag for a data object
  %r28 = getelementptr inbounds %dt46, %dt46* %r7, i32 0, i32 0
  %r27 = load i32, i32* %r28
  ; branch based on the tag value
  switch i32 %r27, label %b1641 [
      i32 0, label %b1473 ]

b1641:
  %r36 = bitcast %dt46* %r7 to %dt53*
  %r37 = getelementptr inbounds %dt53, %dt53* %r36, i32 0, i32 1
  %r33 = load %dt29*, %dt29** %r37
  %r35 = getelementptr inbounds %dt28, %dt28* @val.69, i32 0, i32 0
  %r34 = load %dt27, %dt27* %r35
  %r30 = call %dt31* %r34(%dt28* @val.69, %dt29* %r33)
  %r32 = getelementptr inbounds %dt31, %dt31* %r30, i32 0, i32 0
  %r31 = load %dt30, %dt30* %r32
  %r29 = tail call %dt20* %r31(%dt31* %r30, %dt33* @val.71)
  ret %dt20* %r29

b1473:
  %r89 = bitcast %dt46* %r7 to %dt55*
  %r90 = getelementptr inbounds %dt55, %dt55* %r89, i32 0, i32 1
  %r86 = load %dt54*, %dt54** %r90
  %r87 = bitcast %dt54* %r86 to %dt57*
  %r88 = getelementptr inbounds %dt57, %dt57* %r87, i32 0, i32 1
  %r77 = load %dt34*, %dt34** %r88
  %r84 = bitcast %dt54* %r86 to %dt57*
  %r85 = getelementptr inbounds %dt57, %dt57* %r84, i32 0, i32 2
  %r73 = load %dt34*, %dt34** %r85
  ; calculate the number of bytes that we need to allocate
  %r81 = getelementptr inbounds %dt60, %dt60* null, i32 1
  %r82 = ptrtoint %dt60* %r81 to i32
  ; allocate memory for the object
  %r83 = call i8* @alloc(i32 %r82)
  %r78 = bitcast i8* %r83 to %dt60*
  ; set the tag
  %r80 = getelementptr inbounds %dt60, %dt60* %r78, i32 0, i32 0
  store %dt32 @clos_k512, %dt32* %r80
  ; initialize other fields
  %r79 = getelementptr inbounds %dt60, %dt60* %r78, i32 0, i32 1
  store %dt28* @val.69, %dt28** %r79
  %r70 = bitcast %dt60* %r78 to %dt33*
  %r75 = bitcast %dt34* %r77 to %dt39*
  %r76 = getelementptr inbounds %dt39, %dt39* %r75, i32 0, i32 1
  %r74 = load %dt38*, %dt38** %r76
  %r63 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r74, %dt33* %r70)
  %r71 = bitcast %dt34* %r73 to %dt39*
  %r72 = getelementptr inbounds %dt39, %dt39* %r71, i32 0, i32 1
  %r69 = load %dt38*, %dt38** %r72
  %r61 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r69, %dt33* %r70)
  ; calculate the number of bytes that we need to allocate
  %r66 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r67 = ptrtoint %dt21* %r66 to i32
  ; allocate memory for the object
  %r68 = call i8* @alloc(i32 %r67)
  %r60 = bitcast i8* %r68 to %dt21*
  ; set the tag
  %r65 = getelementptr inbounds %dt21, %dt21* %r60, i32 0, i32 0
  store i32 0, i32* %r65
  ; initialize other fields
  %r64 = getelementptr inbounds %dt21, %dt21* %r60, i32 0, i32 1
  store %dt20* %r63, %dt20** %r64
  %r62 = getelementptr inbounds %dt21, %dt21* %r60, i32 0, i32 2
  store %dt20* %r61, %dt20** %r62
  %r54 = bitcast %dt21* %r60 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r57 = getelementptr inbounds %dt26, %dt26* null, i32 1
  %r58 = ptrtoint %dt26* %r57 to i32
  ; allocate memory for the object
  %r59 = call i8* @alloc(i32 %r58)
  %r53 = bitcast i8* %r59 to %dt26*
  ; set the tag
  %r56 = getelementptr inbounds %dt26, %dt26* %r53, i32 0, i32 0
  store i32 0, i32* %r56
  ; initialize other fields
  %r55 = getelementptr inbounds %dt26, %dt26* %r53, i32 0, i32 1
  store %dt22* %r54, %dt22** %r55
  %r47 = bitcast %dt26* %r53 to %dt24*
  ; calculate the number of bytes that we need to allocate
  %r50 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r51 = ptrtoint %dt25* %r50 to i32
  ; allocate memory for the object
  %r52 = call i8* @alloc(i32 %r51)
  %r46 = bitcast i8* %r52 to %dt25*
  ; set the tag
  %r49 = getelementptr inbounds %dt25, %dt25* %r46, i32 0, i32 0
  store i32 1, i32* %r49
  ; initialize other fields
  %r48 = getelementptr inbounds %dt25, %dt25* %r46, i32 0, i32 1
  store %dt24* %r47, %dt24** %r48
  %r40 = bitcast %dt25* %r46 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r43 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r44 = ptrtoint %dt19* %r43 to i32
  ; allocate memory for the object
  %r45 = call i8* @alloc(i32 %r44)
  %r39 = bitcast i8* %r45 to %dt19*
  ; set the tag
  %r42 = getelementptr inbounds %dt19, %dt19* %r39, i32 0, i32 0
  store i32 0, i32* %r42
  ; initialize other fields
  %r41 = getelementptr inbounds %dt19, %dt19* %r39, i32 0, i32 1
  store %dt18* %r40, %dt18** %r41
  %r38 = bitcast %dt19* %r39 to %dt20*
  ret %dt20* %r38
}

define internal %dt20* @func_b1534(%dt34* %r0) {
  br label %b1534

b1534:
  %r4 = bitcast %dt34* %r0 to %dt39*
  %r5 = getelementptr inbounds %dt39, %dt39* %r4, i32 0, i32 1
  %r3 = load %dt38*, %dt38** %r5
  ; read the tag for a data object
  %r2 = getelementptr inbounds %dt38, %dt38* %r3, i32 0, i32 0
  %r1 = load i32, i32* %r2
  ; branch based on the tag value
  switch i32 %r1, label %b1553 [
      i32 0, label %b1640 ]

b1553:
  %r7 = bitcast %dt38* %r3 to %dt47*
  %r8 = getelementptr inbounds %dt47, %dt47* %r7, i32 0, i32 1
  %r6 = load %dt46*, %dt46** %r8
  br label %b1445

b1640:
  %r24 = bitcast %dt38* %r3 to %dt37*
  %r25 = getelementptr inbounds %dt37, %dt37* %r24, i32 0, i32 1
  %r18 = load i32, i32* %r25
  ; calculate the number of bytes that we need to allocate
  %r21 = getelementptr inbounds %dt17, %dt17* null, i32 1
  %r22 = ptrtoint %dt17* %r21 to i32
  ; allocate memory for the object
  %r23 = call i8* @alloc(i32 %r22)
  %r17 = bitcast i8* %r23 to %dt17*
  ; set the tag
  %r20 = getelementptr inbounds %dt17, %dt17* %r17, i32 0, i32 0
  store i32 0, i32* %r20
  ; initialize other fields
  %r19 = getelementptr inbounds %dt17, %dt17* %r17, i32 0, i32 1
  store i32 %r18, i32* %r19
  %r11 = bitcast %dt17* %r17 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r14 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r15 = ptrtoint %dt19* %r14 to i32
  ; allocate memory for the object
  %r16 = call i8* @alloc(i32 %r15)
  %r10 = bitcast i8* %r16 to %dt19*
  ; set the tag
  %r13 = getelementptr inbounds %dt19, %dt19* %r10, i32 0, i32 0
  store i32 0, i32* %r13
  ; initialize other fields
  %r12 = getelementptr inbounds %dt19, %dt19* %r10, i32 0, i32 1
  store %dt18* %r11, %dt18** %r12
  %r9 = bitcast %dt19* %r10 to %dt20*
  ret %dt20* %r9

b1445:
  ; read the tag for a data object
  %r27 = getelementptr inbounds %dt46, %dt46* %r6, i32 0, i32 0
  %r26 = load i32, i32* %r27
  ; branch based on the tag value
  switch i32 %r26, label %b1641 [
      i32 0, label %b1473 ]

b1641:
  %r35 = bitcast %dt46* %r6 to %dt53*
  %r36 = getelementptr inbounds %dt53, %dt53* %r35, i32 0, i32 1
  %r32 = load %dt29*, %dt29** %r36
  %r34 = getelementptr inbounds %dt28, %dt28* @val.69, i32 0, i32 0
  %r33 = load %dt27, %dt27* %r34
  %r29 = call %dt31* %r33(%dt28* @val.69, %dt29* %r32)
  %r31 = getelementptr inbounds %dt31, %dt31* %r29, i32 0, i32 0
  %r30 = load %dt30, %dt30* %r31
  %r28 = tail call %dt20* %r30(%dt31* %r29, %dt33* @val.71)
  ret %dt20* %r28

b1473:
  %r88 = bitcast %dt46* %r6 to %dt55*
  %r89 = getelementptr inbounds %dt55, %dt55* %r88, i32 0, i32 1
  %r85 = load %dt54*, %dt54** %r89
  %r86 = bitcast %dt54* %r85 to %dt57*
  %r87 = getelementptr inbounds %dt57, %dt57* %r86, i32 0, i32 1
  %r76 = load %dt34*, %dt34** %r87
  %r83 = bitcast %dt54* %r85 to %dt57*
  %r84 = getelementptr inbounds %dt57, %dt57* %r83, i32 0, i32 2
  %r72 = load %dt34*, %dt34** %r84
  ; calculate the number of bytes that we need to allocate
  %r80 = getelementptr inbounds %dt60, %dt60* null, i32 1
  %r81 = ptrtoint %dt60* %r80 to i32
  ; allocate memory for the object
  %r82 = call i8* @alloc(i32 %r81)
  %r77 = bitcast i8* %r82 to %dt60*
  ; set the tag
  %r79 = getelementptr inbounds %dt60, %dt60* %r77, i32 0, i32 0
  store %dt32 @clos_k512, %dt32* %r79
  ; initialize other fields
  %r78 = getelementptr inbounds %dt60, %dt60* %r77, i32 0, i32 1
  store %dt28* @val.69, %dt28** %r78
  %r69 = bitcast %dt60* %r77 to %dt33*
  %r74 = bitcast %dt34* %r76 to %dt39*
  %r75 = getelementptr inbounds %dt39, %dt39* %r74, i32 0, i32 1
  %r73 = load %dt38*, %dt38** %r75
  %r62 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r73, %dt33* %r69)
  %r70 = bitcast %dt34* %r72 to %dt39*
  %r71 = getelementptr inbounds %dt39, %dt39* %r70, i32 0, i32 1
  %r68 = load %dt38*, %dt38** %r71
  %r60 = call %dt20* @func_b1522(%dt28* @val.69, %dt38* %r68, %dt33* %r69)
  ; calculate the number of bytes that we need to allocate
  %r65 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r66 = ptrtoint %dt21* %r65 to i32
  ; allocate memory for the object
  %r67 = call i8* @alloc(i32 %r66)
  %r59 = bitcast i8* %r67 to %dt21*
  ; set the tag
  %r64 = getelementptr inbounds %dt21, %dt21* %r59, i32 0, i32 0
  store i32 0, i32* %r64
  ; initialize other fields
  %r63 = getelementptr inbounds %dt21, %dt21* %r59, i32 0, i32 1
  store %dt20* %r62, %dt20** %r63
  %r61 = getelementptr inbounds %dt21, %dt21* %r59, i32 0, i32 2
  store %dt20* %r60, %dt20** %r61
  %r53 = bitcast %dt21* %r59 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r56 = getelementptr inbounds %dt26, %dt26* null, i32 1
  %r57 = ptrtoint %dt26* %r56 to i32
  ; allocate memory for the object
  %r58 = call i8* @alloc(i32 %r57)
  %r52 = bitcast i8* %r58 to %dt26*
  ; set the tag
  %r55 = getelementptr inbounds %dt26, %dt26* %r52, i32 0, i32 0
  store i32 0, i32* %r55
  ; initialize other fields
  %r54 = getelementptr inbounds %dt26, %dt26* %r52, i32 0, i32 1
  store %dt22* %r53, %dt22** %r54
  %r46 = bitcast %dt26* %r52 to %dt24*
  ; calculate the number of bytes that we need to allocate
  %r49 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r50 = ptrtoint %dt25* %r49 to i32
  ; allocate memory for the object
  %r51 = call i8* @alloc(i32 %r50)
  %r45 = bitcast i8* %r51 to %dt25*
  ; set the tag
  %r48 = getelementptr inbounds %dt25, %dt25* %r45, i32 0, i32 0
  store i32 1, i32* %r48
  ; initialize other fields
  %r47 = getelementptr inbounds %dt25, %dt25* %r45, i32 0, i32 1
  store %dt24* %r46, %dt24** %r47
  %r39 = bitcast %dt25* %r45 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r42 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r43 = ptrtoint %dt19* %r42 to i32
  ; allocate memory for the object
  %r44 = call i8* @alloc(i32 %r43)
  %r38 = bitcast i8* %r44 to %dt19*
  ; set the tag
  %r41 = getelementptr inbounds %dt19, %dt19* %r38, i32 0, i32 0
  store i32 0, i32* %r41
  ; initialize other fields
  %r40 = getelementptr inbounds %dt19, %dt19* %r38, i32 0, i32 1
  store %dt18* %r39, %dt18** %r40
  %r37 = bitcast %dt19* %r38 to %dt20*
  ret %dt20* %r37
}

define internal i32 @func_b910() {
  br label %b910

b910:
  %r28 = call %dt20* @func_b1534(%dt34* @val.75)
  %r26 = call %dt20* @func_b1534(%dt34* @val.75)
  ; calculate the number of bytes that we need to allocate
  %r31 = getelementptr inbounds %dt21, %dt21* null, i32 1
  %r32 = ptrtoint %dt21* %r31 to i32
  ; allocate memory for the object
  %r33 = call i8* @alloc(i32 %r32)
  %r25 = bitcast i8* %r33 to %dt21*
  ; set the tag
  %r30 = getelementptr inbounds %dt21, %dt21* %r25, i32 0, i32 0
  store i32 0, i32* %r30
  ; initialize other fields
  %r29 = getelementptr inbounds %dt21, %dt21* %r25, i32 0, i32 1
  store %dt20* %r28, %dt20** %r29
  %r27 = getelementptr inbounds %dt21, %dt21* %r25, i32 0, i32 2
  store %dt20* %r26, %dt20** %r27
  %r19 = bitcast %dt21* %r25 to %dt22*
  ; calculate the number of bytes that we need to allocate
  %r22 = getelementptr inbounds %dt26, %dt26* null, i32 1
  %r23 = ptrtoint %dt26* %r22 to i32
  ; allocate memory for the object
  %r24 = call i8* @alloc(i32 %r23)
  %r18 = bitcast i8* %r24 to %dt26*
  ; set the tag
  %r21 = getelementptr inbounds %dt26, %dt26* %r18, i32 0, i32 0
  store i32 0, i32* %r21
  ; initialize other fields
  %r20 = getelementptr inbounds %dt26, %dt26* %r18, i32 0, i32 1
  store %dt22* %r19, %dt22** %r20
  %r12 = bitcast %dt26* %r18 to %dt24*
  ; calculate the number of bytes that we need to allocate
  %r15 = getelementptr inbounds %dt25, %dt25* null, i32 1
  %r16 = ptrtoint %dt25* %r15 to i32
  ; allocate memory for the object
  %r17 = call i8* @alloc(i32 %r16)
  %r11 = bitcast i8* %r17 to %dt25*
  ; set the tag
  %r14 = getelementptr inbounds %dt25, %dt25* %r11, i32 0, i32 0
  store i32 1, i32* %r14
  ; initialize other fields
  %r13 = getelementptr inbounds %dt25, %dt25* %r11, i32 0, i32 1
  store %dt24* %r12, %dt24** %r13
  %r5 = bitcast %dt25* %r11 to %dt18*
  ; calculate the number of bytes that we need to allocate
  %r8 = getelementptr inbounds %dt19, %dt19* null, i32 1
  %r9 = ptrtoint %dt19* %r8 to i32
  ; allocate memory for the object
  %r10 = call i8* @alloc(i32 %r9)
  %r4 = bitcast i8* %r10 to %dt19*
  ; set the tag
  %r7 = getelementptr inbounds %dt19, %dt19* %r4, i32 0, i32 0
  store i32 0, i32* %r7
  ; initialize other fields
  %r6 = getelementptr inbounds %dt19, %dt19* %r4, i32 0, i32 1
  store %dt18* %r5, %dt18** %r6
  %r3 = bitcast %dt19* %r4 to %dt20*
  %r1 = call i32 @func_b1220(%dt20* @val.61)
  %r2 = call i32 @func_b1220(%dt20* %r3)
  %r0 = add i32 %r1, %r2
  ret i32 %r0
}

define void @main() {
  %r0 = call i32 @func_b1453(%dt1* @val.11)
  store i32 %r0, i32* @x
  %r1 = call i32 @func_b1456(%dt10* @val.41)
  store i32 %r1, i32* @y
  %r2 = call i32 @func_b1465(%dt18* @val.67)
  store i32 %r2, i32* @z
  %r3 = call i32 @func_b910()
  store i32 %r3, i32* @w
  br label %initialize

initialize:
  br label %main

main:
  br label %b911

b911:
  call void @func_b1089(i32 %r0)
  call void @func_b1089(i32 %r1)
  call void @func_b1089(i32 %r2)
  br label %c148

c148:
  tail call void @func_b1089(i32 %r3)
  ret void
}

